---
title: "prueba codigo rmarkdown"
author: "Sebastian Herrera"
date: "2024-03-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
library(readxl)
BASESITA2 <- read_excel("C:/Users/juan2/Downloads/BASESITA_sin_tp2.xlsx")
attach(BASESITA2)
head(BASESITA2)
```

## Base de datos IT para municipios de Santander ordenada. "Tabla de contingencia"

```{r}
library(dplyr)
BASESITA2 <- arrange(BASESITA2, Año)
with(BASESITA2, table(municipio,Año))
```

## Importacion de capas para la utilizacion de los "mapas".

```{r}
setwd('C:/Users/juan2/Downloads/capas normales finales')
library(sf)
mapa_mpios_sf <- st_read(dsn = '.', layer = 'MGN_MPIO_POLITICO') #se almacena mapa normal
head(mapa_mpios_sf)
```

## Se eliminan las variables que no se van a utilizar:

```{r}
columnas_a_eliminar <- c(4, 5, 6, 7, 8, 9, 10, 11, 12, 13)
mapa_mpios_sf <- mapa_mpios_sf[, -columnas_a_eliminar]  # Eliminar las columnas especificadas
mapa_2 <- mapa_mpios_sf
names(mapa_2)

names(mapa_2) <- c(
  'DPTO_CCDGO', 'MPIO_CCDGO', 'cod_municipio', 'geometry'
)
mapa_2 <- mapa_2[, -1]  # Eliminar las columnas especificadas
mapa_2 <- mapa_2[, -1]  # Eliminar las columnas especificadas
head(mapa_2)
```

## Union de la base de datos de la TMI de Santander y las capas de los mapas.

```{r}
mapa_22 <- merge(mapa_2, BASESITA2, by = c("cod_municipio"))
```

################################################################################################################################################################################################################################

#Importacion productos agricolas

```{r}
library(readxl)
agro <- read_excel("C:/Users/juan2/Downloads/Evaluaciones_Agropecuarias_Municipales_EVA_20240228 final.xlsx")
attach(agro)
head(agro)
```

```{r}
library(ggplot2)
library(dplyr)

# Resumen de los datos
agro_sum <- agro %>% 
  group_by(Ano, DEPARTAMENTO) %>%
  summarise(Produccion_sum = sum(`Produccion t`))

# Crear el gráfico
ggplot1 <- ggplot(agro_sum, 
                  aes(x = Ano, y = Produccion_sum, group = DEPARTAMENTO, color = factor(DEPARTAMENTO))) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  labs(title = "Producción agrícola a nivel nacional y por departamento",
       subtitle = "2010-2021",
       x = "Año",
       y = "Producción Total",
       color = "Departamento") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        strip.text = element_text(size = 12),
        plot.title = element_text(size = 14, hjust = 0.5),
        plot.subtitle = element_text(size = 12, hjust = 0.5, color = "gray40"))

# Imprimir el gráfico
print(ggplot1)
```

```{r}
library(viridis)
library(lubridate)
agro$Ano <- as.Date(as.character(agro$Ano), format="%Y")

ggplot(data = agro, aes(x = as.factor(year(Ano)), y = log(`Produccion t`), fill = as.factor(year(Ano)))) +
  geom_boxplot() +
  scale_fill_viridis(discrete = TRUE) +
  labs(x = 'Año', y = 'Tasa de Produccion', title = 'Diagrama de caja TP\npor año') + 
  theme(axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 12, angle = 0, vjust = 0.5, hjust = 0.5),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        strip.text = element_text(size = 14),
        legend.position = 'none',
        plot.title = element_text(hjust = 0.5, size = 24, face = 'bold'))
```

```{r}
library(dplyr)
library(ggplot2)

# Calcular la sumatoria de producción por año y municipio
produccion_por_ano_municipio <- agro %>%
  group_by(MUNICIPIO, Ano) %>%
  summarise(Produccion_total = sum(`Produccion t`))

# Crear el gráfico
ggplot(produccion_por_ano_municipio, aes(x = Ano, y = Produccion_total, group = MUNICIPIO, color = MUNICIPIO)) +
  geom_line(color = "#4477AA") +  # Por ejemplo, azul oscuro
  geom_point(size = 2, color = "#4477AA") +  # Mismo color para los puntos
  facet_wrap(~MUNICIPIO, scales = 'free_y', ncol = 10) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8, angle = 90),
    axis.title = element_text(size = 10),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12, hjust = 0.5),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"
  ) +
  labs(title = "Producción por Municipio en Santander")
```

```{r}
### Se añadió la nueva columna de sumatoria de produccion.
agro <- agro %>%
  left_join(produccion_por_ano_municipio, by = c("MUNICIPIO", "Ano"))

#####

agro <- agro %>%
  rename(
    cod_municipio = COD.MUN,
    municipio = MUNICIPIO,
    Año = Ano
    # Agrega más renombramientos si es necesario
  )

library(dplyr)
agro$Año <- year(agro$Año)

# Resumir los datos de agro para obtener la producción total por municipio y año
#agro_resumen <- agro %>%
#group_by(municipio, Año) %>%
#summarise(Produccion_total = sum(Produccion_total, na.rm = TRUE), .groups = 'drop')

# Calcular la suma de la producción por año y municipio en agro_resumen
agroresu2 <- agro %>%
  group_by(municipio, Año) %>%
  summarise(Produccion_total = sum(`Produccion t`, na.rm = TRUE)) %>%
  ungroup()

# Verificar la suma para un año y municipio específico
produccion_2021_lebrija <- agro %>%
  filter(municipio == "LEBRIJA" & Año == 2021) %>%
  summarise(total_production = sum(`Produccion t`, na.rm = TRUE))

mapa_2234456 <- merge(mapa_22, agroresu2, by = c("municipio", "Año"), all.x = TRUE)
```
## importacion proyeccion de poblacion:
```{r}
library(readxl)
proyeccion_poblacion_final <- read_excel("C:/Users/juan2/Downloads/proyeccion poblacion final.xlsx")
```

```{r}
library(dplyr)
mapa_2234456 <- mapa_2234456 %>%
  left_join(select(proyeccion_poblacion_final, municipio, Año, Población), by = c("municipio", "Año"))
```

PRODUCCION PERCAPITA:


```{r}
attach(mapa_2234456)
mapa_2234456$produccion_percapita<-Produccion_total/Población
```

Tasa de producción. “Cantidad de alimentos que se envían del campo a la ciudad".

Una forma común de interpretar la producción en relación con el número de habitantes es calcular la producción per cápita. Esto se hace dividiendo la producción total entre el número de habitantes del municipio. La producción per cápita representa la cantidad promedio de producción por persona en el municipio. Una producción per cápita alta puede indicar una economía próspera y una buena calidad de vida para los residentes.
Por ejemplo, una producción alta en relación con el número de habitantes puede indicar una economía local sólida que proporciona empleo y oportunidades económicas para los residentes. Esto puede contribuir al crecimiento económico y al bienestar social en el municipio.

Si la producción se mide en toneladas, la interpretación sería en términos de la cantidad total de bienes producidos en el municipio en relación con el número de habitantes

cantidad total de producción en toneladas entre diferentes municipios para evaluar su rendimiento económico relativo. Por ejemplo, si un municipio produce más toneladas de bienes que otro, podría indicar una economía más activa o una industria más desarrollada en ese municipio.

Puedes calcular la producción per cápita dividiendo la producción total en toneladas entre el número de habitantes del municipio. Esto te dará una medida de la cantidad promedio de producción por persona en el municipio. Una producción per cápita más alta podría indicar una mayor productividad o eficiencia en la economía local.

Cantidad total de bienes producidos en el municipio y su impacto en la economía local y la calidad de vida de sus residentes. Es importante considerar esta medida en relación con otros factores, como el tamaño de la población y la estructura económica del municipio, para obtener una comprensión completa de su significado.
 
 
## Tasa de ingreso per capita: Ingreso total x municipio / Cantidad de personas x municipio

```{r}
mapa_2234456$Ingreso_per_capita <- `INGRESOS TOTALES`/Población
```

Esto dará una medida del ingreso promedio por persona en cada municipio.

## Tasa de ingreso relativo al salario minimo: Ingreso total / Salario minimo x año.

```{r}
library(dplyr)

salario_minimo<-c(515000,535600,566700,589500,616000,644350,689455,737717,781242,828116,877803,908526)

resultados <- mapa_2234456 %>%
  group_by(municipio, Año) %>%
  mutate(ingreso_relativo = `INGRESOS TOTALES` / salario_minimo[match(Año, unique(mapa_2234456$Año))]) %>%
  ungroup()
resultados

resultados_df <- st_drop_geometry(resultados)

columna_ingreso_relativo <- resultados_df  %>%
  select(Año, municipio, ingreso_relativo)

head(columna_ingreso_relativo)

mapa_2234456 <- left_join(mapa_2234456, columna_ingreso_relativo, by = c("Año", "municipio"))

# Visualizar los primeros registros del dataframe actualizado
head(mapa_2234456)

```
################################################################################################################################################################################################################################

```{r}
attach(mapa_2234456)
mapa_2234456$ingreso_relativopob <- ingreso_relativo/Población
mapa_2234456$ingreso_relativo1000 <- ingreso_relativo/1000
attach(mapa_2234456)
```

MPM DE CERO A UNO NORMALIZADA:

```{r}
mapa_2234456$MPM01<-mapa_2234456$MPM/100
```

## tmi que seria: sin lo de x1000 nacidos vivos:

```{r}
mapa_2234456$TMISIN1000<- mapa_2234456$TMI/1000
```

## TMP tambien estaba x1000 nacidos vivos

```{r}
mapa_2234456$TMPSIN1000<- mapa_2234456$tasa/1000
```

```{r}
attach(mapa_2234456)
```

## TMI CARACTERISTICAS:

Cociente entre el número de defunciones en niños y niñas menores de un año y el número de nacidos vivos en un territorio y un periodo determinado y multiplicado por 1.000.

Se interpreta como la probabilidad de sobrevida durante el primer año de vida de los niños que nacen. Es un indicador muy importante en salud pública.

Ej: alcanza una tasa de 12,2 muertes infantiles por 1.000 nacidos vivos

número de niños que mueren antes de cumplir un año de edad por cada 1000 niños nacidos vivos en una determinada población y período de tiempo.

en promedio, 15.6 de cada 1000 niños nacidos vivos fallecen antes de cumplir un año de edad en la población considerada. 


############################################################################################################################################################################################################################################

## Afiliados al SGSSS

```{r}
library(readxl)
sgss <- read_excel("C:/Users/juan2/Downloads/sgss.xlsx")
head(sgss)
```

```{r}
library(dplyr)
mapa_2234456 <- mapa_2234456 %>%
  left_join(select(sgss, municipio, Año, "Dato Numérico"), by = c("municipio", "Año"))
head(mapa_2234456)

# Calcula el porcentaje
mapa_2234456$datosnumericoporc <- (mapa_2234456$`Dato Numérico` / mapa_2234456$Población) * 100

```

##########################################################################################################



################################################################################################################################################################################################################################
############################################## HASTA AQUI LA BASE DE DATOS #####################################
################################################################################################################

## convertir tmp a tasa:

```{r}
mapa_2234456$TMI_tasa <- mapa_2234456$TMI / 100
mapa_2234456$TMP_tasa <- mapa_2234456$tasa / 100
```

## Log con pequeña cte y sin cte en ingresos, mpm y produccion

```{r}
mapa_2234456$log_TMI <- log(mapa_2234456$TMI_tasa + 1e-6)  # 1e-6 es un pequeño valor constante
mapa_2234456$log_tasa <- log(mapa_2234456$TMP_tasa + 1e-6)  # 1e-6 es un pequeño valor constante
#datos_2021$log_MPM <- log(datos_2021$MPM)
mapa_2234456$log_ingtotal <- log(mapa_2234456$`INGRESOS TOTALES`)
mapa_2234456$log_MPM <- log(mapa_2234456$MPM)
mapa_2234456$log_Produccion_total <- log(mapa_2234456$Produccion_total)
```

## Calculo de normalizacion de la variable:

```{r}
media_TMI <- mean(mapa_2234456$TMI_tasa)
desviacion_TMI <- sd(mapa_2234456$TMI_tasa)
mapa_2234456$TMI_normalizadoc <- (mapa_2234456$TMI_tasa - media_TMI) / desviacion_TMI
head(mapa_2234456$TMI_normalizadoc)
str(mapa_2234456$TMI_normalizadoc)
summary(mapa_2234456$TMI_normalizadoc)
```

## Calculo de normalizacion del log TMI:

```{r}
media_TMI <- mean(mapa_2234456$log_TMI)
desviacion_TMI <- sd(mapa_2234456$log_TMI)
mapa_2234456$TMI_normalizadoc2 <- (mapa_2234456$log_TMI - media_TMI) / desviacion_TMI
head(mapa_2234456$TMI_normalizadoc2)
str(mapa_2234456$TMI_normalizadoc2)
summary(mapa_2234456$TMI_normalizadoc2)
```

## Calculo de normalizacion de la variable:

```{r}
media_TMP <- mean(mapa_2234456$TMP_tasa)
desviacion_TMP <- sd(mapa_2234456$TMP_tasa)
mapa_2234456$TMP_normalizadoc <- (mapa_2234456$TMP_tasa - media_TMP) / desviacion_TMP
head(mapa_2234456$TMP_normalizadoc)
str(mapa_2234456$TMP_normalizadoc)
summary(mapa_2234456$TMP_normalizadoc)
```

## Calculo de normalizacion del log de TMP:

```{r}
media_TMP <- mean(mapa_2234456$log_tasa)
desviacion_TMP <- sd(mapa_2234456$log_tasa)
mapa_2234456$TMP_normalizadoc2 <- (mapa_2234456$log_tasa - media_TMP) / desviacion_TMP
head(mapa_2234456$TMP_normalizadoc2)
str(mapa_2234456$TMP_normalizadoc2)
summary(mapa_2234456$TMP_normalizadoc2)
```

# NORMALIZACION DEL INGRESO

```{r}
# Calcular la media y la desviación estándar de la columna icldneto
it_normalizmean <- mean(mapa_2234456$`INGRESOS TOTALES`, na.rm = TRUE)
it_normalizsd <- sd(mapa_2234456$`INGRESOS TOTALES`, na.rm = TRUE)

# Normalizar la columna utilizando la fórmula Z-score
mapa_2234456$it_normalizadaAA <- (mapa_2234456$`INGRESOS TOTALES` - it_normalizmean) / it_normalizsd
head(mapa_2234456$it_normalizadaAA)
str(mapa_2234456$it_normalizadaAA)
summary(mapa_2234456$it_normalizadaAA)
```

# NORMALIZACION DEL LOG

```{r}
it_normalizmean <- mean(mapa_2234456$log_ingtotal, na.rm = TRUE)
it_normalizsd <- sd(mapa_2234456$log_ingtotal, na.rm = TRUE)
mapa_2234456$it_normalizadaAA2 <- (mapa_2234456$log_ingtotal - it_normalizmean) / it_normalizsd
```

# NORMALIZACION DE PRODUCCION

```{r}
# Calcular la media y la desviación estándar de la columna icldneto
prod_normalizmean <- mean(mapa_2234456$Produccion_total, na.rm = TRUE)
prod_normalizsd <- sd(mapa_2234456$Produccion_total, na.rm = TRUE)

# Normalizar la columna utilizando la fórmula Z-score
mapa_2234456$prod_normalizadaAA <- (mapa_2234456$Produccion_total - prod_normalizmean) / prod_normalizsd
head(mapa_2234456$prod_normalizadaAA)
str(mapa_2234456$prod_normalizadaAA)
summary(mapa_2234456$prod_normalizadaAA)
```

## NORMALIZACION DE LOG DE PRODUCCION

```{r}
prod_normalizmean <- mean(mapa_2234456$log_Produccion_total, na.rm = TRUE)
prod_normalizsd <- sd(mapa_2234456$log_Produccion_total, na.rm = TRUE)
mapa_2234456$prod_normalizadaAA2 <- (mapa_2234456$log_Produccion_total - prod_normalizmean) / prod_normalizsd
```

## NORMALIZACION DE MPM

```{r}
# Calcular la media y la desviación estándar de la columna icldneto
MPM_normalizmean <- mean(mapa_2234456$MPM, na.rm = TRUE)
MPM_normalizsd <- sd(mapa_2234456$MPM, na.rm = TRUE)

# Normalizar la columna utilizando la fórmula Z-score
mapa_2234456$MPM_normalizadaAA <- (mapa_2234456$MPM - MPM_normalizmean) / MPM_normalizsd
head(mapa_2234456$MPM_normalizadaAA)
str(mapa_2234456$MPM_normalizadaAA)
summary(mapa_2234456$MPM_normalizadaAA)
```

## NORMALIZACION DE LOG MPM

```{r}
mpm_normalizmean <- mean(mapa_2234456$log_MPM, na.rm = TRUE)
mpm_normalizsd <- sd(mapa_2234456$log_MPM, na.rm = TRUE)
mapa_2234456$mpm_normalizadaAA2 <- (mapa_2234456$log_MPM - mpm_normalizmean) / mpm_normalizsd
```

## SOLO POR SI ACASO LOG DEL LOG CON LA CTE

mapa_2234456$log_TMIC <- log(mapa_2234456$TMI)  # 1e-6 es un pequeño valor constante
mapa_2234456$log_TMPC <- log(mapa_2234456$TMP_normalizadoc)  # 1e-6 es un pequeño valor constante
mapa_2234456$log_ingtotalAA <- log(mapa_2234456$it_normalizadaAA)
mapa_2234456$log_Produccion_totalAA <- log(mapa_2234456$prod_normalizadaAA)

#####################################################################################################################
#####################################################################################################################

############################################################################################################################################################################################################################################

```{r}
library(readxl)
TMITERRIDATA <- read_excel("C:/Users/juan2/Downloads/TMITERRIDATA.xlsx")
head(TMITERRIDATA)
```

```{r}
TMITERRIDATA$cod_municipio <- as.character(TMITERRIDATA$cod_municipio)
mapa_2234456 <- left_join(mapa_2234456, TMITERRIDATA, by = c("municipio", "Año", "cod_municipio"))
head(mapa_2234456)
```


####################################################################################################################################################################################################################################################################################################################################################################################################################

## CON EL ARREGLO DE LAS VARIABLES PEDIDO POR CARLOS:

```{r}
library(gridExtra)
library(ggplot2)

VSBNola11<-ggplot(data = mapa_2234456, aes(x = TMP_tasa, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'TMP', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 10),
        axis.text = element_text(size = 10))

VSBNola<-ggplot(data = mapa_2234456, aes(x = MPM01, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'IPM', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 10),
        axis.text = element_text(size = 10))

VSBN3ola<-ggplot(data = mapa_2234456, aes(x = log(ingreso_relativo), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'ing_relativo', y = 'TMI') +
  theme_bw()

VSBN4ola<-ggplot(data = mapa_2234456, aes(x = log(produccion_percapita), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'log(prod_percapita)', y = 'TMI') +
  theme_bw()

#VSBN4ola4<-ggplot(data = mapa_2234456, aes(x = log(Produccion_total), y = TMI_TERRIDATA)) +
  #geom_point() +
  #geom_smooth(method = "loess") +
  #labs(x = 'log(produccio total)', y = 'TMI') +
  #theme_bw()
grid.arrange(VSBNola11,VSBNola, VSBN3ola, VSBN4ola, ncol = 4)


##
VSBNo234<-ggplot(data = mapa_2234456, aes(x = BSCPI_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'BSCPI_TOT', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBNo2345<-ggplot(data = mapa_2234456, aes(x = BASS_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'BASS_TOT', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBN323456<-ggplot(data = mapa_2234456, aes(x = log(SAFAM_TOT), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'SAFAM_TOT', y = 'TMI') +
  theme_bw()

grid.arrange(VSBNo234,VSBNo2345, VSBN323456, ncol = 3)
```
##  

VSBNo234455<-ggplot(data = datos_2010sgss2, aes(x = log(porcentaje_no_asegurados2010), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'SGSSS', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBNo23454556<-ggplot(data = datos_2016sgss2, aes(x = log(porcentaje_no_asegurados2016), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'SGSSS', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBN32345645567<-ggplot(data = datos_2020sgss2, aes(x = log(porcentaje_no_asegurados), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'SGSSS', y = 'TMI') +
  theme_bw()

grid.arrange(VSBNo234455,VSBNo23454556, VSBN32345645567, ncol = 3)


solo para ver mejor el grafico

```{r}
datos_2020 <- subset(mapa_2234456, Año == 2020)
```


```{r}
#library(rgdal)    # Importación de Datos (puntos, líneas, polígonos)
#library(maptools) # Herramientas de Visualización
library(gstat)    # Geoestadística
library(spatstat) # Geoestadística
library(plotly)   # Proyecciones
```

Esta georreferenciación permite asociar los datos a una región o territorio lo que facilita comprender la forma como se desarrollan los fenómenos en el lugar donde suceden. Usar datos espaciales permite tener un concepto más amplio de lo que son región y territorio y perfilar mejor los enfoques de medición y/o políticas públicas.

```{r}
library(ggplot2)
plot(datos_2020$geometry, pch = 20, col = 'red',  cex = 0.1,
main = 'Mapa de Municipios',
sub = 'Fuente: Dane')
```

## Sin el rojo:

```{r}
plot(datos_2020$geometry)
```

```{r}
head(datos_2020)
str(datos_2020)

library(sf)
library(spdep)

# Suponiendo que 'datos_sf' es tu objeto de datos espaciales en formato sf

# Extraer las coordenadas de los centroides
map_crd2020 <- st_centroid(datos_2020)

# Crear vecindad de la reina
W_vot2020 <- poly2nb(datos_2020, queen = TRUE)

# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2020 <- nb2listw(W_vot2020, style = "W", zero.policy = TRUE)

# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords <- st_coordinates(map_crd2020)

# Tramar los municipios
plot(datos_2020$geometry, border = "grey")

# Agregar los centroides
points(coords[, "X"], coords[, "Y"], pch = 19, cex = 0.1, col = "red")

# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2020$neighbours)) {
  vecinos <- W_vot_mat2020$neighbours[[i]]
  for (j in vecinos) {
    lines(c(coords[i, "X"], coords[j, "X"]), c(coords[i, "Y"], coords[j, "Y"]), col = "red")
  }
}

```

#MORAN NORMAL

```{r}
resultado_tasa_TMI2020 <- moran.test(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T)
```

# normalizado da lo mismo que arriba.
# moran.test(datos_2021$TMI_normalizadoc, listw=W_vot_mat2021, zero.policy=T)

```{r}
resultado_tasa_MPM2020 <- moran.test(datos_2020$MPM01, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_tasa_TMP2020 <- moran.test(datos_2020$TMPSIN1000, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_ingresos2020 <- moran.test(datos_2020$ingreso_relativo, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_ingresos22020 <- moran.test(datos_2020$Ingreso_per_capita, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_produccion2020 <- moran.test(datos_2020$produccion_percapita, listw=W_vot_mat2020, zero.policy=T)
```


print(resultado_tasa_TMI2021)
print(resultado_tasa_TMP2021)
print(resultado_tasa_MPM2021)
print(resultado_ingresos2021)
print(resultado_ingresos22021)
print(resultado_produccion2021)

### agrupacion:

```{r}
tabla_resultadosmoran2020 <- data.frame(
  Indicador = c("TMI Tasa", "TMP Tasa", "MPM", "Ingresos relativo","Ingreso percapita", "Producción Total"),
  Estadístico_Moran = c(resultado_tasa_TMI2020$estimate[1], resultado_tasa_TMP2020$estimate[1], resultado_tasa_MPM2020$estimate[1], resultado_ingresos2020$estimate[1],resultado_ingresos22020$estimate[1], resultado_produccion2020$estimate[1]),
  Valor_P = c(resultado_tasa_TMI2020$p.value, resultado_tasa_TMP2020$p.value, resultado_tasa_MPM2020$p.value, resultado_ingresos2020$p.value, resultado_ingresos22020$p.value,resultado_produccion2020$p.value)
)
tabla_resultadosmoran2020
```

#### Nota: puede haber con log en ingreso una mejora:

#INGRESO MEJORA DE 0.15 A 0.20

```{r}
datos_2020$iiig <- log(datos_2020$Ingreso_per_capita)
moran.test(datos_2020$iiig, listw=W_vot_mat2020, zero.policy=T)
```
```{r}
datos_2020$iiig2 <- datos_2020$ingreso_relativo
moran.test(log(datos_2020$iiig2), listw=W_vot_mat2020, zero.policy=T)
```
```{r}
#datos_2021$probando <- datos_2021$log_TMI)
moran.test(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T)
```
```{r}
#datos_2021$probando <- datos_2021$log_TMI)
moran.test(log(datos_2020$produccion_percapita), listw=W_vot_mat2020, zero.policy=T)
```

#datos_2021$probando <- datos_2021$log_TMI)
moran.test(datos_2021$log_tasa, listw=W_vot_mat2021, zero.policy=T)


################################################## 2010 #############################################
#################################################### 2010 ######################################################

```{r}
datos_2010 <- subset(mapa_2234456, Año == 2010)
```

```{r}
head(datos_2010)
str(datos_2010)
library(sf)
library(spdep)
# Suponiendo que 'datos_sf' es tu objeto de datos espaciales en formato sf  
# Extraer las coordenadas de los centroides
map_crd2010 <- st_centroid(datos_2010)

# Crear vecindad de la reina
W_vot2010 <- poly2nb(datos_2010, queen = TRUE)

# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2010 <- nb2listw(W_vot2010, style = "W", zero.policy = TRUE)

# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords2 <- st_coordinates(map_crd2010)
# Tramar los municipios
plot(datos_2010$geometry, border = "grey")
# Agregar los centroides
points(coords2[, "X"], coords2[, "Y"], pch = 19, cex = 0.1, col = "red")
# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2010$neighbours)) {
  vecinos2 <- W_vot_mat2010$neighbours[[i]]
  for (j in vecinos2) {
    lines(c(coords2[i, "X"], coords2[j, "X"]), c(coords2[i, "Y"], coords2[j, "Y"]), col = "red")
  }
}
```
#MORAN NORMAL

```{r}
resultado_tasa_TMI2010 <- moran.test(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_tasa_MPM2010 <- moran.test(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_tasa_TMP2010 <- moran.test(datos_2010$TMPSIN1000, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_ingresos2010 <- moran.test(datos_2010$ingreso_relativo, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_ingresos20102 <- moran.test(datos_2010$Ingreso_per_capita, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_produccion2010 <- moran.test(datos_2010$produccion_percapita, listw=W_vot_mat2010, zero.policy=T)
```

print(resultado_tasa_TMI2010)
print(resultado_tasa_TMP2010)
print(resultado_tasa_MPM2010)
print(resultado_ingresos2010)
print(resultado_ingresos20102)
print(resultado_produccion2010)

```{r}
tabla_resultadosmoran2010 <- data.frame(
  Indicador = c("TMI Tasa", "TMP Tasa", "MPM", "Ingresos relativo","Ingreso percapita", "Producción Total"),
  Estadístico_Moran = c(resultado_tasa_TMI2010$estimate[1], resultado_tasa_TMP2010$estimate[1], resultado_tasa_MPM2010$estimate[1], resultado_ingresos2010$estimate[1],resultado_ingresos20102$estimate[1], resultado_produccion2010$estimate[1]),
  Valor_P = c(resultado_tasa_TMI2010$p.value, resultado_tasa_TMP2010$p.value, resultado_tasa_MPM2010$p.value, resultado_ingresos2010$p.value, resultado_ingresos20102$p.value,resultado_produccion2010$p.value)
)
tabla_resultadosmoran2010
```

# SIGUE SIN SER SIGNIFICATIVO 

```{r}
datos_2010$iiig <- log(datos_2010$Ingreso_per_capita)
moran.test(datos_2010$iiig, listw=W_vot_mat2010, zero.policy=T)
```
# PASA DE 0.14 A 0.36

```{r}
datos_2010$iiig2 <- log(datos_2010$ingreso_relativo)
moran.test(datos_2010$iiig2, listw=W_vot_mat2010, zero.policy=T)
```
```{r}
#datos_2010$probando <- log(datos_2010$log_TMI)
moran.test(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
#datos_2010$probando <- log(datos_2010$log_TMI)
moran.test(datos_2010$log_tasa, listw=W_vot_mat2010, zero.policy=T)
```
```{r}
#datos_2010$probando <- log(datos_2010$log_TMI)
moran.test(log(datos_2010$produccion_percapita), listw=W_vot_mat2010, zero.policy=T)
```

################################################## 2016 #############################################
#####################################################################################################

```{r}
datos_2016 <- subset(mapa_2234456, Año == 2016)
```

```{r}
head(datos_2016)
str(datos_2016)
library(sf)
library(spdep)
# Suponiendo que 'datos_sf' es tu objeto de datos espaciales en formato sf
# Extraer las coordenadas de los centroides
map_crd2016 <- st_centroid(datos_2016)

# Crear vecindad de la reina
W_vot2016 <- poly2nb(datos_2016, queen = TRUE)

# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2016 <- nb2listw(W_vot2016, style = "W", zero.policy = TRUE)

# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords2 <- st_coordinates(map_crd2016)
# Tramar los municipios
plot(datos_2016$geometry, border = "grey")
# Agregar los centroides
points(coords2[, "X"], coords2[, "Y"], pch = 19, cex = 0.1, col = "red")
# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2016$neighbours)) {
  vecinos2 <- W_vot_mat2016$neighbours[[i]]
  for (j in vecinos2) {
    lines(c(coords2[i, "X"], coords2[j, "X"]), c(coords2[i, "Y"], coords2[j, "Y"]), col = "red")
  }
}
```
```{r}
resultado_tasa_TMI2016 <- moran.test(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_tasa_MPM2016 <- moran.test(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_tasa_TMP2016 <- moran.test(datos_2016$TMPSIN1000, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_ingresos2016 <- moran.test(datos_2016$ingreso_relativo, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_ingresos20162 <- moran.test(datos_2016$Ingreso_per_capita, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_produccion2016 <- moran.test(datos_2016$produccion_percapita, listw=W_vot_mat2016, zero.policy=T)
```


print(resultado_tasa_TMI2016)
print(resultado_tasa_TMP2016)
print(resultado_tasa_MPM2016)
print(resultado_ingresos2016)
print(resultado_ingresos20162)
print(resultado_produccion2016)


```{r}
tabla_resultadosmoran2016 <- data.frame(
  Indicador = c("TMI Tasa", "TMP Tasa", "MPM", "Ingresos relativo","Ingreso percapita", "Producción Total"),
  Estadístico_Moran = c(resultado_tasa_TMI2016$estimate[1], resultado_tasa_TMP2016$estimate[1], resultado_tasa_MPM2016$estimate[1], resultado_ingresos2016$estimate[1],resultado_ingresos20162$estimate[1], resultado_produccion2016$estimate[1]),
  Valor_P = c(resultado_tasa_TMI2016$p.value, resultado_tasa_TMP2016$p.value, resultado_tasa_MPM2016$p.value, resultado_ingresos2016$p.value, resultado_ingresos20162$p.value,resultado_produccion2016$p.value)
)
tabla_resultadosmoran2016
```
## PASA DE 0.06 Y NO SIGNIFICATIVO A 0.15 Y SIGNIFICATIVO

```{r}
datos_2016$iiig <- log(datos_2016$Ingreso_per_capita)
moran.test(datos_2016$iiig, listw=W_vot_mat2016, zero.policy=T)
```
PASA DE 0.17 A 0.34

```{r}
datos_2016$iiig2 <- log(datos_2016$ingreso_relativo)
moran.test(datos_2016$iiig2, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
#datos_2016$probando <- log(datos_2016$log_TMI)
moran.test(datos_2016$log_TMI, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
#datos_2016$probando <- log(datos_2016$log_TMI)
moran.test(datos_2016$log_tasa, listw=W_vot_mat2016, zero.policy=T)
```
```{r}
#datos_2016$probando <- log(datos_2016$log_TMI)
moran.test(log(datos_2016$produccion_percapita), listw=W_vot_mat2016, zero.policy=T)
```

##########################################################################################################################################################################################################
############################################## MODELOS ##############################################
##########################################################################################################


Nota: las variables dependientes ninguna es significativa.    

# LINEAL:

```{r}
mod.lm2010 <- lm(TMI_TERRIDATA ~ MPM01+log(ingreso_relativo)+log(produccion_percapita), data=datos_2010)
summary(mod.lm2010)
```

```{r}
mod.lm20102 <- lm(TMI_TERRIDATA ~ log(ingreso_relativo)+log(produccion_percapita), data=datos_2010)
summary(mod.lm20102)
```

```{r}
mod.lm20103 <- lm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+log(produccion_percapita), data=datos_2010)
summary(mod.lm20103)
```

```{r}
mod.lm20104 <- lm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data=datos_2010)
summary(mod.lm20104)
```

#####################################################################################################

```{r}
library(spatialreg)
mod.sar2010 <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(Ingreso_per_capita)+log(produccion_percapita), data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-17)
summary(mod.sar2010)
```

```{r}
library(spatialreg)
mod.sar20102 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-14)
summary(mod.sar20102)
```

```{r}
library(spatialreg)
mod.sar20103 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-12)
summary(mod.sar20103)
```

```{r}
library(spatialreg)
mod.sar20104 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar20104)
```

#####################################################################################################

```{r}
## SEM
mod.sem2010 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-17)
summary(mod.sem2010)
```

```{r}
## SEM
mod.sem20102 <- errorsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20102)
```

```{r}
## SEM
mod.sem20103 <- errorsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103)
```

```{r}
## SEM
mod.sem20104 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20104)
```


#####################################################################################################

```{r}
## SDM 
mod.sdm2010 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm2010)
```

```{r}
## SDM 
mod.sdm20102 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm20102)
```

```{r}
## SDM 
mod.sdm20103 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-12)
summary(mod.sdm20103)
```

```{r}
## SDM 
mod.sdm20104 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-16)
summary(mod.sdm20104)
```

################################################ criterio aic #######################################

```{r}
AIC(mod.lm2010,mod.lm20102,mod.lm20103, mod.lm20104)
```

```{r}
AIC(mod.sar2010,mod.sar20102,mod.sar20103,mod.sar20104)
```

```{r}
AIC(mod.sem2010,mod.sem20102,mod.sem20103,mod.sem20104)
```

```{r}
AIC(mod.sdm2010,mod.sdm20102,mod.sdm20103, mod.sdm20104)
```



#####################################################################################################
############################################ 2016 modelos ###########################################
#####################################################################################################



# LINEAL:

```{r}
mod.lm2016 <- lm(TMI_TERRIDATA ~ MPM01+log(Ingreso_per_capita)+produccion_percapita, data=datos_2016)
summary(mod.lm2016)
```

```{r}
mod.lm20162 <- lm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data=datos_2016)
summary(mod.lm20162)
```

```{r}
mod.lm20163 <- lm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data=datos_2016)
summary(mod.lm20163)
```

```{r}
mod.lm20164 <- lm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data=datos_2016)
summary(mod.lm20164)
```

####################### SAR

```{r}
library(spatialreg)
mod.sar2016 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-17)
summary(mod.sar2016)
```

```{r}
library(spatialreg)
mod.sar20162 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar20162)
```

```{r}
library(spatialreg)
mod.sar20163 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-12)
summary(mod.sar20163)
```

```{r}
library(spatialreg)
mod.sar20164 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar20164)
```

#####################################################################################################

```{r}
## SEM
mod.sem2016 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-17)
summary(mod.sem2016)
```

```{r}
## SEM
mod.sem20162 <- errorsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20162)
```

```{r}
## SEM
mod.sem20163 <- errorsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163)
```

```{r}
## SEM
mod.sem20164 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20164)
```

#####################################################################################################

```{r}
## SDM 
mod.sdm2016 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm2016)
```

```{r}
## SDM 
mod.sdm20162 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm20162)
```


```{r}
## SDM 
mod.sdm20163 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-12)
summary(mod.sdm20163)
```

```{r}
## SDM 
mod.sdm20164 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-16)
summary(mod.sdm20164)
```


################################################ criterio aic #######################################

```{r}
AIC(mod.lm2016,mod.lm20162,mod.lm20163, mod.lm20164)
```

```{r}
AIC(mod.sar2016,mod.sar20162,mod.sar20163,mod.sar20164)
```

```{r}
AIC(mod.sem2016,mod.sem20162,mod.sem20163,mod.sem20164)
```

```{r}
AIC(mod.sdm2016,mod.sdm20162,mod.sdm20163, mod.sdm20164)
```



#####################################################################################################
################################################### 2021 ############################################
#####################################################################################################
#####################################################################################################


# LINEAL:

```{r}
mod.lm2020 <- lm(TMI_TERRIDATA ~ MPM01+log(Ingreso_per_capita)+produccion_percapita, data=datos_2020)
summary(mod.lm2020)
```

```{r}
mod.lm20202 <- lm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data=datos_2020)
summary(mod.lm20202)
```

```{r}
mod.lm20203 <- lm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data=datos_2020)
summary(mod.lm20203)
```

```{r}
mod.lm20204 <- lm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data=datos_2020)
summary(mod.lm20204)
```


####################### SAR


```{r}
library(spatialreg)
mod.sar2020 <- lagsarlm(TMI_TERRIDATA ~ MPM01+ingreso_relativo+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-18)
summary(mod.sar2020)
```

```{r}
library(spatialreg)
mod.sar20202 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-17)
summary(mod.sar20202)
```

```{r}
library(spatialreg)
mod.sar20203 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-12)
summary(mod.sar20203)
```

```{r}
library(spatialreg)
mod.sar20204 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20204)
```


#####################################################################################################

```{r}
## SEM
mod.sem2020 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-18)
summary(mod.sem2020)
```

```{r}
## SEM
mod.sem20202 <- errorsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20202)
```

```{r}
## SEM
mod.sem20203 <- errorsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203)
```

```{r}
## SEM
mod.sem20204 <- errorsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20204)
```

#####################################################################################################

```{r}
## SDM 
mod.sdm2020 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-18)
summary(mod.sdm2020)
```

```{r}
## SDM 
mod.sdm20202 <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-18)
summary(mod.sdm20202)
```


```{r}
## SDM 
mod.sdm20203 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita)+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm20203)
```

```{r}
## SDM 
mod.sdm20204 <- lagsarlm(TMI_TERRIDATA ~ MPM01+Ingreso_per_capita+produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204)
```

################################################ criterio aic #######################################

```{r}
AIC(mod.lm2020,mod.lm20202,mod.lm20203, mod.lm20204)
```

```{r}
AIC(mod.sar2020,mod.sar20202,mod.sar20203,mod.sar20204)
```

```{r}
AIC(mod.sem2020,mod.sem20202,mod.sem20203,mod.sem20204)
```

```{r}
AIC(mod.sdm2020,mod.sdm20202, mod.sdm20203, mod.sdm20204)
```

###############################################################################################################################################################################################################################################################################################################

CRITERIOS AIC GENERALES

```{r}
AIC(mod.lm2016,mod.sar2016,mod.sem2016, mod.sdm2016)
```

```{r}
AIC(mod.lm20162,mod.sar20162,mod.sem20162,mod.sdm20162)
```

```{r}
AIC(mod.lm20163,mod.sar20163,mod.sem20163,mod.sdm20163)
```

```{r}
AIC(mod.lm20164,mod.sar20164, mod.sem20164, mod.sdm20164)
```

#

```{r}
AIC(mod.lm2010,mod.sar2010,mod.sem2010, mod.sdm2010)
```

```{r}
AIC(mod.lm20102,mod.sar20102,mod.sem20102,mod.sdm20102)
```

```{r}
AIC(mod.lm20103,mod.sar20103,mod.sem20103,mod.sdm20103)
```

```{r}
AIC(mod.lm20104,mod.sar20104, mod.sem20104, mod.sdm20104)
```

##############################################################################################################################################################################################################################################################################################################################

UNIVARIANTE

POR INDIVIDUAL

```{r}
mod.lm2020MPM <- lm(TMI_TERRIDATA ~ MPM01, data=datos_2020)
summary(mod.lm2020MPM)
```
```{r}
mod.lm2020ING <- lm(TMI_TERRIDATA ~ ingreso_relativo, data=datos_2020)
summary(mod.lm2020ING)
```
```{r}
mod.lm2020ING2 <- lm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data=datos_2020)
summary(mod.lm2020ING2)
```

```{r}
mod.lm2020PROD <- lm(TMI_TERRIDATA ~ log(produccion_percapita), data=datos_2020)
summary(mod.lm2020PROD)
```
## SAR UNIVARIANTE:

```{r}
library(spatialreg)
mod.sar20204MPM <- lagsarlm(TMI_TERRIDATA~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20204MPM)
```
moran.test(mod.sar20204MPM$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar20204INGR <- lagsarlm(TMI_TERRIDATA ~ log(ingreso_relativo), data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20204INGR)
```
moran.test(mod.sar20204INGR$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar20204INGR2 <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20204INGR2)
```

```{r}
library(spatialreg)
mod.sar20204PP <- lagsarlm(TMI_TERRIDATA~ produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20204PP)
```
moran.test(mod.sar20204PP$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SEM
mod.sem20203mpm <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203mpm)
```
moran.test(mod.sem20203mpm$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SEM
mod.sem20203ing <- errorsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203ing)
```
```{r}
## SEM
mod.sem20203ing2 <- errorsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203ing2)
```
moran.test(mod.sem20203ing2$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SEM
mod.sem20203prod <- errorsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203prod)
```
moran.test(mod.sem20203prod$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20204mpm <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204mpm)
```
moran.test(mod.sar20204MPM$residuals, listw = W_vot_mat2020, zero.policy = TRUE)


```{r}
## SDM 
mod.sdm20204ing <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204ing)
```
```{r}
## SDM 
mod.sdm20204ing2 <- lagsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204ing2)
```
moran.test(mod.sdm20204ing2$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20204prod <- lagsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204prod)
```
moran.test(mod.sdm20204prod$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

## mejor modelo

```{r}
AIC(mod.sar20204MPM,mod.sem20203mpm,mod.sdm20204mpm)
```

## MEJOR MODELO INGRESO

```{r}
AIC(mod.sar20204INGR,mod.sem20203ing2,mod.sdm20204ing2)
```
# MEJOR MODELO PRODUCCION:

```{r}
AIC(mod.sar20204PP,mod.sem20203prod,mod.sdm20204prod)
```


#####################################################################################################

```{r}
mod.lm2016MPM <- lm(TMI_TERRIDATA ~ MPM01, data=datos_2016)
summary(mod.lm2016MPM)
```

```{r}
mod.lm2016ING <- lm(TMI_TERRIDATA ~ Ingreso_per_capita, data=datos_2016)
summary(mod.lm2016ING)
```

```{r}
mod.lm2016PROD <- lm(TMI_TERRIDATA ~ produccion_percapita, data=datos_2016)
summary(mod.lm2016PROD)
```

```{r}
library(spatialreg)
mod.sar2016MPM <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM)
```
moran.test(mod.sar2016MPM$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar20216INGR <- lagsarlm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20216INGR)
```
```{r}
library(spatialreg)
mod.sar20216INGR2 <- lagsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20216INGR2)
```
moran.test(mod.sar20216INGR2$residuals, listw = W_vot_mat2016, zero.policy = TRUE)


```{r}
library(spatialreg)
mod.sar2016Prod <- lagsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016Prod)
```
moran.test(mod.sar2016Prod$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SEM
mod.sem20163mpm <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163mpm)
```
moran.test(mod.sem20163mpm$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SEM
mod.sem20163ing <- errorsarlm(TMI_TERRIDATA ~ Ingreso_per_capita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163ing)
```
```{r}
## SEM
mod.sem20163ing2 <- errorsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163ing2)
```
moran.test(mod.sem20163ing2$residuals, listw = W_vot_mat2016, zero.policy = TRUE)


```{r}
## SEM
mod.sem20163prod <- errorsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod)
```
moran.test(mod.sem20163prod$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20164mpm <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm)
```
moran.test(mod.sdm20164mpm$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20164ing <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164ing)
```
```{r}
## SDM 
mod.sdm20164ing2 <- lagsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164ing2)
```
moran.test(mod.sdm20164ing2$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm2016prod <- lagsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm2016prod)
```
moran.test(mod.sdm2016prod$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

## modelos mpm

```{r}
AIC(mod.sar2016MPM,mod.sem20163mpm,mod.sdm20164mpm)
```

## MODELOS INGESOS RELATIVOS

```{r}
AIC(mod.sar20216INGR2,mod.sem20163ing2,mod.sdm20164ing2)
```

## MODELOS PRODUCCION

```{r}
AIC(mod.sar2016Prod,mod.sem20163prod,mod.sdm2016prod)
```

#####################################################################################################
# 2010
```{r}
mod.lm2010MPM <- lm(TMI_TERRIDATA ~ MPM01, data=datos_2010)
summary(mod.lm2010MPM)
```

```{r}
mod.lm2010ING <- lm(TMI_TERRIDATA ~ log(Ingreso_per_capita), data=datos_2010)
summary(mod.lm2010ING)
```
```{r}
mod.lm2010ING2 <- lm(TMI_TERRIDATA ~ log(ingreso_relativo), data=datos_2010)
summary(mod.lm2010ING2)
```


```{r}
mod.lm2010PROD <- lm(TMI_TERRIDATA ~ log(produccion_percapita), data=datos_2010)
summary(mod.lm2010PROD)
```

```{r}
library(spatialreg)
mod.sar2010MPM <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM)
```
moran.test(mod.sar2010MPM$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar20210INGR <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20210INGR)
```
```{r}
library(spatialreg)
mod.sar20210INGR2 <- lagsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar20210INGR2)
```
moran.test(mod.sar20210INGR2$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar2010Prod <- lagsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010Prod)
```
moran.test(mod.sar2010Prod$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SEM
mod.sem20103mpm <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103mpm)
```
moran.test(mod.sem20103mpm$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SEM
mod.sem20103ing <- errorsarlm(TMI_TERRIDATA ~ Ingreso_per_capita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103ing)
```
```{r}
## SEM
mod.sem20103ing2 <- errorsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103ing2)
```
moran.test(mod.sem20103ing2$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SEM
mod.sem20103prod <- errorsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod)
```
moran.test(mod.sem20103prod$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20104mpm <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104mpm)
```
moran.test(mod.sdm20104mpm$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20104ing <- lagsarlm(TMI_TERRIDATA ~ Ingreso_per_capita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104ing)
```
```{r}
## SDM 
mod.sdm20104ing2 <- lagsarlm(TMI_TERRIDATA ~ ingreso_relativo, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104ing2)
```
moran.test(mod.sdm20104ing2$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm2010prod <- lagsarlm(TMI_TERRIDATA ~ produccion_percapita, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm2010prod)
```
moran.test(mod.sdm2010prod$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

## mejor mpm

```{r}
AIC(mod.sar2010MPM,mod.sem20103mpm,mod.sdm20104mpm)
```

# MEJOR MODELO INGRESO RELATIVO
```{r}
AIC(mod.sar20210INGR2,mod.sem20103ing2,mod.sdm20104ing2)
```
## MEJOR MODELO PRODUCCION
```{r}
AIC(mod.sar2010Prod,mod.sem20103prod,mod.sdm2010prod)
```
```{r}
AIC(mod.sar2016Prod,mod.sem20163prod,mod.sdm2016prod)
```

```{r}
AIC(mod.sar20204PP,mod.sem20203prod,mod.sdm20204prod)
```

####################################################################################################################################################################################################################################################################################################################################################################################################################################

### ANALIS CON 3 DIMENSIONES EN ESPECIFICO DEL: BARRERAS DE ACCESO A SERVICIOS PARA EL CUIDADO DE LA PRIMERA INFANCIA, BARRERAS DE ACCESO A SERVICIO DE SALUD, SIN ACCESO A FUENTES DE AGUA MEJORADA.

```{r}
library(gridExtra)
af<-ggplot(data = mapa_2234456, aes(x =BSCPI_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'BSCPI_TOT', y = 'TMI') +
  theme_bw()

aff<-ggplot(data = mapa_2234456, aes(x = BASS_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'BASS_TOT', y = 'TMI') +
  theme_bw()

afff<-ggplot(data = mapa_2234456, aes(x = SAFAM_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'SAFAM_TOT', y = 'TMI') +
  theme_bw()

affff<-ggplot(data = mapa_2234456, aes(x = MPM01, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'MPM', y = 'TMI') +
  theme_bw()

grid.arrange(af, aff, afff, affff, ncol = 4)

```

```{r}
library(gridExtra)
af<-ggplot(data = mapa_2234456, aes(x =log(BSCPI_TOT), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'BSCPI_TOT', y = 'TMI') +
  theme_bw()

aff<-ggplot(data = mapa_2234456, aes(x = BASS_TOT, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'BASS_TOT', y = 'TMI') +
  theme_bw()

afff<-ggplot(data = mapa_2234456, aes(x = log(SAFAM_TOT), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'Log(SAFAM_TOT)', y = 'TMI') +
  theme_bw()

affff<-ggplot(data = mapa_2234456, aes(x = MPM01, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = "loess") +
  labs(x = 'MPM', y = 'TMI') +
  theme_bw()

grid.arrange(af, aff, afff, affff, ncol = 4)

```

## 2010

```{r}
resultado_tasa_TMI2010 <- moran.test(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_tasa_MPM2010 <- moran.test(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_BSCPI2010 <- moran.test(datos_2010$BSCPI_TOT, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_BASS2010 <- moran.test(datos_2010$BASS_TOT, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
resultado_SAFAM2010 <- moran.test(datos_2010$SAFAM_TOT, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
print(resultado_tasa_TMI2010)
print(resultado_tasa_MPM2010)
print(resultado_BSCPI2010)
print(resultado_BASS2010)
print(resultado_SAFAM2010)
```   

```{r}
tabla2_resultadosmoran2010 <- data.frame(
  Indicador = c("TMI Tasa", "MPM", "BSCPI", "BASS", "SAFAM"),
  Estadístico_Moran = c(resultado_tasa_TMI2010$estimate[1], resultado_tasa_MPM2010$estimate[1], resultado_BSCPI2010$estimate[1], resultado_BASS2010$estimate[1], resultado_SAFAM2010$estimate[1]),
  Valor_P = c(resultado_tasa_TMI2010$p.value, resultado_tasa_MPM2010$p.value, resultado_BSCPI2010$p.value, resultado_BASS2010$p.value, resultado_SAFAM2010$p.value)
)
tabla2_resultadosmoran2010
```

moran.test(log(datos_2010$SAFAM_TOT), listw=W_vot_mat2010, zero.policy=T)

```{r}
moran.test(log(datos_2010$BASS_TOT), listw=W_vot_mat2010, zero.policy=T)
```

```{r}
moran.test(log(datos_2010$BSCPI_TOT), listw=W_vot_mat2010, zero.policy=T)
```

## 2016

```{r}
resultado_tasa_TMI2016 <- moran.test(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_tasa_MPM2016 <- moran.test(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_BSCPI2016 <- moran.test(datos_2016$BSCPI_TOT, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_BASS2016 <- moran.test(datos_2016$BASS_TOT, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
resultado_SAFAM2016 <- moran.test(datos_2016$SAFAM_TOT, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
print(resultado_tasa_TMI2016)
print(resultado_tasa_MPM2016)
print(resultado_BSCPI2016)
print(resultado_BASS2016)
print(resultado_SAFAM2016)
```

```{r}
tabla2_resultadosmoran2016 <- data.frame(
  Indicador = c("TMI", "MPM", "BSCPI", "BASS", "SAFAM"),
  Estadístico_Moran = c(resultado_tasa_TMI2016$estimate[1], resultado_tasa_MPM2016$estimate[1], resultado_BSCPI2016$estimate[1], resultado_BASS2016$estimate[1], resultado_SAFAM2016$estimate[1]),
  Valor_P = c(resultado_tasa_TMI2016$p.value, resultado_tasa_MPM2016$p.value, resultado_BSCPI2016$p.value, resultado_BASS2016$p.value, resultado_SAFAM2016$p.value)
)
tabla2_resultadosmoran2016
```

moran.test(log(datos_2016$SAFAM_TOT), listw=W_vot_mat2016, zero.policy=T)

```{r}
moran.test(log(datos_2016$BASS_TOT), listw=W_vot_mat2016, zero.policy=T)
```

```{r}
moran.test(log(datos_2016$BSCPI_TOT), listw=W_vot_mat2016, zero.policy=T)
```

```{r}
moran.test(datos_2016$log_TMI, listw=W_vot_mat2016, zero.policy=T)
```

## 2020

```{r}
resultado_tasa_TMI <- moran.test(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_tasa_MPM <- moran.test(datos_2020$MPM01, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_BSCPI <- moran.test(datos_2020$BSCPI_TOT, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_BASS <- moran.test(datos_2020$BASS_TOT, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
resultado_SAFAM <- moran.test(datos_2020$SAFAM_TOT, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
print(resultado_tasa_TMI)
print(resultado_tasa_MPM)
print(resultado_BSCPI)
print(resultado_BASS)
print(resultado_SAFAM)
```

```{r}
tabla2_resultadosmoran2021 <- data.frame(
  Indicador = c("TMI Tasa", "MPM", "BSCPI", "BASS", "SAFAM"),
  Estadístico_Moran = c(resultado_tasa_TMI$estimate[1], resultado_tasa_MPM$estimate[1], resultado_BSCPI$estimate[1], resultado_BASS$estimate[1], resultado_SAFAM$estimate[1]),
  Valor_P = c(resultado_tasa_TMI$p.value, resultado_tasa_MPM$p.value, resultado_BSCPI$p.value, resultado_BASS$p.value, resultado_SAFAM$p.value)
)
tabla2_resultadosmoran2021
```

moran.test(log(datos_2021$SAFAM_TOT), listw=W_vot_mat2021, zero.policy=T)

```{r}
moran.test(log(datos_2020$BASS_TOT), listw=W_vot_mat2020, zero.policy=T)
```

```{r}
moran.test(log(datos_2020$BSCPI_TOT), listw=W_vot_mat2020, zero.policy=T)
```

```{r}
moran.test(datos_2020$log_TMI, listw=W_vot_mat2020, zero.policy=T)
```

################################################################################################################################################################################################################################################################# modelos: ################################################
#########################################################################################################


```{r}
library(spatialreg)
mod.sar2020 <- lagsarlm(TMI_TERRIDATA ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-12)
summary(mod.sar2020)
```

```{r}
## SEM
mod.sem2020 <- errorsarlm(TMI_TERRIDATA ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020)
```

```{r}
## SDM 
mod.sdm2020 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-12)
summary(mod.sdm2020)
```

```{r}
AIC(mod.sar2020,mod.sem2020,mod.sdm2020)
```

#########################################################################################################

```{r}
library(spatialreg)
mod.sar2016 <- lagsarlm(TMI_TERRIDATA ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-12)
summary(mod.sar2016)
```

```{r}
## SEM
mod.sem2016 <- errorsarlm(TMI_TERRIDATA ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016)
```

```{r}
## SDM 
mod.sdm2016 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-12)
summary(mod.sdm2016)
```

```{r}
AIC(mod.sar2016,mod.sem2016,mod.sdm2016)
```

#########################################################################################################

```{r}
library(spatialreg)
mod.sar2010 <- lagsarlm(TMI_TERRIDATA ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-12)
summary(mod.sar2010)
```

```{r}
## SEM
mod.sem2010 <- errorsarlm(TMISIN1000 ~ MPM01+BSCPI_TOT+SAFAM_TOT+BASS_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010)
```

```{r}
## SDM 
mod.sdm2010 <- lagsarlm(TMISIN1000 ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-12)
summary(mod.sdm2010)
```

```{r}
AIC(mod.sar2010,mod.sem2010,mod.sdm2010)
```
##################################################################################################################################################################################################################
#########################################################################################################
#########################################################################################################

```{r}
## SEM
mod.sem20103prod1 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod1)
```

```{r}
## SDM 
mod.sdm20104mpm1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104mpm1)
```

```{r}
library(spatialreg)
mod.sar2010MPM1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM1)
```

```{r}
## SEM
mod.sem20163prod1 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod1)
```

```{r}
## SDM 
mod.sdm20164mpm1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm1)
```

```{r}
library(spatialreg)
mod.sar2016MPM1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM1)
```

```{r}
## SEM
mod.sem20203prod1 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20203prod1)
```

```{r}
## SDM 
mod.sdm20204mpm1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20204mpm1)
```

```{r}
library(spatialreg)
mod.sar2020MPM1 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT+BASS_TOT+SAFAM_TOT+MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2020MPM1)
```


###########################################################################################################################################################################################################################################################################################################################

ENFOQUE UNIVARIANTE

sar

2016

```{r}
library(spatialreg)
mod.sar2016MPM1UNIV20163 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM1UNIV20163)
```

```{r}
library(spatialreg)
mod.sar2016MPM1UNIV201632 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM1UNIV201632)
```
moran.test(mod.sar2016MPM1UNIV201632$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar2016MPM1UNIV201633 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM1UNIV201633)
```

```{r}
library(spatialreg)
mod.sar2016MPM1UNIV201644 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2016MPM1UNIV201644)
```
moran.test(mod.sar2016MPM1UNIV201644$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

2010

```{r}
library(spatialreg)
mod.sar2010MPM1UNIV201041 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM1UNIV201041)
```

```{r}
library(spatialreg)
mod.sar2010MPM1UNIV201042 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM1UNIV201042)
```
moran.test(mod.sar2010MPM1UNIV201042$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar2010MPM1UNIV201043 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM1UNIV201043)
```

```{r}
library(spatialreg)
mod.sar2010MPM1UNIV201044 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2010MPM1UNIV201044)
```
moran.test(mod.sar2010MPM1UNIV201044$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

2020

```{r}
library(spatialreg)
mod.sar2020MPM1UNIV202141 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2020MPM1UNIV202141)
```

```{r}
library(spatialreg)
mod.sar2021MPM1UNIV202042 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2021MPM1UNIV202042)
```
moran.test(mod.sar2021MPM1UNIV202042$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
library(spatialreg)
mod.sar2021MPM1UNIV202143 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2021MPM1UNIV202143)
```

```{r}
library(spatialreg)
mod.sar2021MPM1UNIV202144 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-16)
summary(mod.sar2021MPM1UNIV202144)
```
moran.test(mod.sar2021MPM1UNIV202144$residuals, listw = W_vot_mat2020, zero.policy = TRUE)


#########################################################################################################

SEM

2016

```{r}
## SEM
mod.sem20163prod1UNIV20161 <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod1UNIV20161)
```

```{r}
## SEM
mod.sem20163prod1UNIV20162 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod1UNIV20162)
```
moran.test(mod.sem20163prod1UNIV20162$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SEM
mod.sem20163prod1UNIV20163 <- errorsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod1UNIV20163)
```

```{r}
## SEM
mod.sem20163prod1UNIV20164 <- errorsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20163prod1UNIV20164)
```
moran.test(mod.sem20163prod1UNIV20164$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

2010

```{r}
## SEM
mod.sem20103prod1UNIV20101 <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod1UNIV20101)
```

```{r}
## SEM
mod.sem20103prod1UNIV20102 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod1UNIV20102)
```
moran.test(mod.sem20103prod1UNIV20102$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SEM
mod.sem20103prod1UNIV20103 <- errorsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod1UNIV20103)
```

```{r}
## SEM
mod.sem20103prod1UNIV20104 <- errorsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20103prod1UNIV20104)
```
moran.test(mod.sem20103prod1UNIV20104$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

2021

```{r}
## SEM
mod.sem20213prod1UNIV20211 <- errorsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20213prod1UNIV20211)
```

```{r}
## SEM
mod.sem20213prod1UNIV20212 <- errorsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20213prod1UNIV20212)
```
moran.test(mod.sem20213prod1UNIV20212$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SEM
mod.sem20213prod1UNIV20213 <- errorsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20213prod1UNIV20213)
```

```{r}
## SEM
mod.sem20213prod1UNIV20214 <- errorsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem20213prod1UNIV20214)
```
moran.test(mod.sem20213prod1UNIV20214$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

#########################################################################################################

SDM

2021

```{r}
## SDM 
mod.sdm20214mpm11 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20214mpm11)
```

```{r}
## SDM 
mod.sdm20214mpm12 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20214mpm12)
```
moran.test(mod.sdm20214mpm12$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20214mpm13 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20214mpm13)
```

```{r}
## SDM 
mod.sdm20214mpm14 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20214mpm14)
```
moran.test(mod.sdm20214mpm14$residuals, listw = W_vot_mat2020, zero.policy = TRUE)

2016

```{r}
## SDM 
mod.sdm20164mpm1 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm1)
```

```{r}
## SDM 
mod.sdm20164mpm12 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm12)
```
moran.test(mod.sdm20164mpm12$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20164mpm13 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm13)
```

```{r}
## SDM 
mod.sdm20164mpm14 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20164mpm14)
```
moran.test(mod.sdm20164mpm14$residuals, listw = W_vot_mat2016, zero.policy = TRUE)

2010

```{r}
## SDM 
mod.sdm20214mpm1 <- lagsarlm(TMI_TERRIDATA ~ MPM01, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20214mpm1)
```

```{r}
## SDM 
mod.sdm20104mpm2 <- lagsarlm(TMI_TERRIDATA ~ BSCPI_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104mpm2)
```
moran.test(mod.sdm20104mpm2$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

```{r}
## SDM 
mod.sdm20104mpm3 <- lagsarlm(TMI_TERRIDATA ~ BASS_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104mpm3)
```

```{r}
## SDM 
mod.sdm20104mpm4 <- lagsarlm(TMI_TERRIDATA ~ SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-17)
summary(mod.sdm20104mpm4)
```
moran.test(mod.sdm20104mpm4$residuals, listw = W_vot_mat2010, zero.policy = TRUE)

# test aic SAFAM

```{r}
AIC(mod.sar2016MPM1UNIV201644,mod.sem20163prod1UNIV20164,mod.sdm20164mpm14)
```

```{r}
AIC(mod.sar2010MPM1UNIV201044,mod.sem20103prod1UNIV20104,mod.sdm20104mpm4)
```

```{r}
AIC(mod.sar2021MPM1UNIV202144,mod.sem20213prod1UNIV20214,mod.sdm20214mpm14)
```

### BSCPI

```{r}
AIC(mod.sar2016MPM1UNIV201632,mod.sem20163prod1UNIV20162,mod.sdm20164mpm12)
```

```{r}
AIC(mod.sar2010MPM1UNIV201042,mod.sem20103prod1UNIV20102,mod.sdm20104mpm2)
```

```{r}
AIC(mod.sar2021MPM1UNIV202042,mod.sem20213prod1UNIV20212,mod.sdm20214mpm12)
```

### AIC BASS
```{r}
AIC(mod.sar2010MPM1UNIV201043,mod.sem20103prod1UNIV20103,mod.sdm20104mpm3)
```

```{r}
AIC(mod.sar2016MPM1UNIV201633,mod.sem20163prod1UNIV20163,mod.sdm20164mpm13)
```

```{r}
AIC(mod.sar2021MPM1UNIV202143,mod.sem20213prod1UNIV20213,mod.sdm20214mpm13)
```

##################################################################################################################################################################################################################

APUNTES:

AIC más bajo SDM, lo que indica un buen ajuste con una penalización por la complejidad.

Relacionar la tasa de mortalidad infantil con la pobreza multidimensional y sus tres dimensiones es un enfoque importante para comprender las interacciones entre estos factores y cómo afectan la salud infantil.

La pobreza multidimensional generalmente se refiere a la privación en múltiples aspectos de la vida, como educación, salud, vivienda, etc

La tasa de mortalidad infantil es un indicador crítico de la salud de una población y se define como el número de muertes de niños menores de un año por cada 1,000 nacidos vivos en un año determinado.

Es importante tener en cuenta que la tasa de mortalidad infantil puede estar influenciada por una variedad de factores, que van desde la atención médica hasta las condiciones socioeconómicas y ambientales.

Modelo de regresión espacial para examinar la relación entre la tasa de mortalidad infantil, la pobreza multidimensional y sus dimensiones. Este enfoque es útil para capturar las interacciones espaciales y examinar cómo las variables se relacionan entre sí a través del espacio.


NOTA: 
 En lugar de ello, tendrías que interpretar los coeficientes en términos del cambio porcentual en la tasa de mortalidad infantil asociado con un cambio unitario en la variable predictora, debido a la naturaleza de la transformación logarítmica.
 
El cambio porcentual en la tasa de mortalidad infantil asociado con un cambio unitario en las toneladas, bajo la suposición de que el resto de las variables en el modelo se mantienen constantes.



####################################################################################################################################################################################################################



####################################################################################################################################################################################################################

```{r}
datos_2012 <- subset(mapa_2234456, Año == 2012)
```


datos_2020 <- subset(mapa_2234456, Año == 2020)


##########################################################################################################

```{r}
#library(rgdal)    # Importación de Datos (puntos, líneas, polígonos)
#library(maptools) # Herramientas de Visualización
library(gstat)    # Geoestadística
library(spatstat) # Geoestadística
library(plotly)   # Proyecciones
```

Esta georreferenciación permite asociar los datos a una región o territorio lo que facilita comprender la forma como se desarrollan los fenómenos en el lugar donde suceden. Usar datos espaciales permite tener un concepto más amplio de lo que son región y territorio y perfilar mejor los enfoques de medición y/o políticas públicas.


```{r}
library(ggplot2)
plot(datos_2012$geometry, pch = 20, col = 'red',  cex = 0.1,
main = 'Mapa de Municipios',
sub = 'Fuente: Dane')
```

## Sin el rojo:

```{r}
plot(datos_2012$geometry)
```

```{r}
head(datos_2012)
str(datos_2012)
library(sf)
library(spdep)
# Extraer las coordenadas de los centroides
map_crd2012 <- st_centroid(datos_2012)
# Crear vecindad de la reina
W_vot2012 <- poly2nb(datos_2012, queen = TRUE)
# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2012 <- nb2listw(W_vot2012, style = "W", zero.policy = TRUE)
# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords <- st_coordinates(map_crd2012)
# Tramar los municipios
plot(datos_2012$geometry, border = "grey")
# Agregar los centroides
points(coords[, "X"], coords[, "Y"], pch = 19, cex = 0.1, col = "red")
# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2012$neighbours)) {
  vecinos <- W_vot_mat2012$neighbours[[i]]
  for (j in vecinos) {
    lines(c(coords[i, "X"], coords[j, "X"]), c(coords[i, "Y"], coords[j, "Y"]), col = "red")
  }
}
```

```{r}
attach(mapa_2234456)
library(gridExtra)
library(ggplot2)

# Ahora, graficar los datos con la línea de regresión ajustada
ggplot(data = mapa_2234456, aes(x =log(`Dato Numérico`), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'log(SGSS)', y = 'log_TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))
```


moran.test(datos_2012$`Dato Numérico`, listw=W_vot_mat2012, zero.policy=T)


2020

```{r}
head(datos_2020)
str(datos_2020)
library(sf)
library(spdep)
# Suponiendo que 'datos_sf' es tu objeto de datos espaciales en formato sf
# Extraer las coordenadas de los centroides
map_crd2020 <- st_centroid(datos_2020)
# Crear vecindad de la reina
W_vot2020 <- poly2nb(datos_2020, queen = TRUE)
# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2020 <- nb2listw(W_vot2020, style = "W", zero.policy = TRUE)
# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords <- st_coordinates(map_crd2020)
# Tramar los municipios
plot(datos_2020$geometry, border = "grey")
# Agregar los centroides
points(coords[, "X"], coords[, "Y"], pch = 19, cex = 0.1, col = "red")
# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2020$neighbours)) {
  vecinos <- W_vot_mat2020$neighbours[[i]]
  for (j in vecinos) {
    lines(c(coords[i, "X"], coords[j, "X"]), c(coords[i, "Y"], coords[j, "Y"]), col = "red")
  }
}
```

```{r}
moran.test(datos_2012$`Dato Numérico`, listw=W_vot_mat2012, zero.policy=T)
```
moran.test(datos_2012$`datosnumericoporc`, listw=W_vot_mat2012, zero.policy=T)
datosnumericoporc
```{r}
moran.test(datos_2020$`Dato Numérico`, listw=W_vot_mat2020, zero.policy=T)
```
moran.test(datos_2020$`datosnumericoporc`, listw=W_vot_mat2020, zero.policy=T)

```{r}
moran.test(datos_2016$`Dato Numérico`, listw=W_vot_mat2016, zero.policy=T)
```
moran.test(datos_2016$`datosnumericoporc`, listw=W_vot_mat2016, zero.policy=T)

```{r}
library(spatialreg)
mod.sar2012scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, tol.solve=1e-14)
summary(mod.sar2012scss)
```
moran.test(mod.sar2012scss$residuals, listw=W_vot_mat2012, zero.policy=TRUE)

mod.sar2012scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, tol.solve=1e-14)
summary(mod.sar2012scss)

```{r}
library(spatialreg)
mod.sar2016scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-14)
summary(mod.sar2016scss)
```
moran.test(mod.sar2016scss$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sar2016scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-14)
summary(mod.sar2016scss)


```{r}
library(spatialreg)
mod.sar2020scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020scss)
```
moran.test(mod.sar2020scss$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sar2020scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020scss)

#######################################################

```{r}
## SEM
mod.sem2016scss <- errorsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016scss)
```
moran.test(mod.sem2016scss$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sem2016scss <- errorsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016scss)

```{r}
## SEM
mod.sem2012scss <- errorsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2012scss)
```
moran.test(mod.sem2012scss$residuals, listw=W_vot_mat2012, zero.policy=TRUE)

mod.sem2012scss <- errorsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2012scss)

```{r}
## SEM
mod.sem2020scss <- errorsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020scss)
```
moran.test(mod.sem2020scss$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sem2020scss <- errorsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020scss)

########

```{r}
## SDM 
mod.sdm2020scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020scss)
```
moran.test(mod.sdm2020scss$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sdm2020scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020scss)

```{r}
## SDM 
mod.sdm2016scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016scss)
```
moran.test(mod.sdm2016scss$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sdm2016scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016scss)

```{r}
## SDM 
mod.sdm2012scss <- lagsarlm(TMI_TERRIDATA ~ `Dato Numérico`, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2012scss)
```
moran.test(mod.sdm2012scss$residuals, listw=W_vot_mat2012, zero.policy=TRUE)

mod.sdm2012scss <- lagsarlm(TMI_TERRIDATA ~ datosnumericoporc, data = datos_2012, listw=W_vot_mat2012, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2012scss)

Afiliados al SGSSS YA

#### mejor modelo:

```{r}
AIC(mod.sar2012scss,mod.sem2012scss,mod.sdm2012scss)
```

```{r}
AIC(mod.sar2016scss,mod.sem2016scss,mod.sdm2016scss)
```

```{r}
AIC(mod.sar2020scss,mod.sem2020scss,mod.sdm2020scss)
```

###############################################################################################################################################################################################################################################################################################################

IMPORTACION NACIMIENTOS:

```{r}
library(readxl)
X2016_naci <- read_excel("C:/Users/juan2/Downloads/2016 naci.xlsx")
```

```{r}
library(readxl)
X2021_naci <- read_excel("C:/Users/juan2/Downloads/2021 naci.xlsx")
```

```{r}
library(readxl)
naci_2010 <- read_excel("C:/Users/juan2/Downloads/naci 2010.xlsx")
```

```{r}
library(readxl)
naci_2020 <- read_excel("C:/Users/juan2/Downloads/naci 2020.xlsx")
```

```{r}
head(naci_2020)
```


##########################################################################################################################################################################################################

### sgss version 2
```{r}
datos_filtrados2020sgss2 <- naci_2020[naci_2020$SEG_SOCIAL %in% c(1,2,3,4,9), ]
head(datos_filtrados2020sgss2)
library(dplyr)
conteo_por_municipio2020sgss2 <- datos_filtrados2020sgss2 %>%
  filter( SEG_SOCIAL %in% c(1,2,3,4,9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())
conteo_por_municipio2020sgss2 <- conteo_por_municipio2020sgss2 %>%
  rename(SEG_SOCIAL = conteo)
```

```{r}
total_nacidos_por_municipio2020 <- naci_2020 %>%
  group_by(municipio) %>%
  summarize(total_nacidos = n())
conteo_por_municipio_final2020 <- left_join(conteo_por_municipio2020sgss2, total_nacidos_por_municipio2020, by = "municipio")
conteo_por_municipio_final2020 <- conteo_por_municipio_final2020 %>%
  mutate(porcentaje_no_asegurados = round(SEG_SOCIAL / total_nacidos * 100,2))
print(conteo_por_municipio_final2020)
```

```{r}
datos_filtrados2016sgss2 <- X2016_naci[X2016_naci$SEG_SOCIAL %in% c(1,2,3,4,9), ]
head(datos_filtrados2016sgss2)
conteo_por_municipio2016sgss2 <- datos_filtrados2016sgss2 %>%
  filter( SEG_SOCIAL %in% c(1,2,3,4,9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())
conteo_por_municipio2016sgss2 <- conteo_por_municipio2016sgss2 %>%
  rename(SEG_SOCIAL = conteo)
```

```{r}
total_nacidos_por_municipio2016 <- X2016_naci %>%
  group_by(municipio) %>%
  summarize(total_nacidos2016 = n())
conteo_por_municipio_final2016 <- left_join(conteo_por_municipio2016sgss2, total_nacidos_por_municipio2016, by = "municipio")
conteo_por_municipio_final2016 <- conteo_por_municipio_final2016 %>%
  mutate(porcentaje_no_asegurados2016 = round(SEG_SOCIAL / total_nacidos2016 * 100,2))
print(conteo_por_municipio_final2016)
```

```{r}
datos_filtrados2010sgss2 <- naci_2010[naci_2010$SEG_SOCIAL %in% c(1,2,3,4,9), ]
head(datos_filtrados2010sgss2)
#datos_filtrados2010sgss2 <- datos_filtrados2010sgss2[complete.cases(datos_filtrados2010sgss2), ]
conteo_por_municipio2010sgss2 <- datos_filtrados2010sgss2 %>%
  filter( SEG_SOCIAL %in% c(1,2,3,4,9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())
conteo_por_municipio2010sgss2 <- conteo_por_municipio2010sgss2 %>%
  rename(SEG_SOCIAL = conteo)
```

```{r}
total_nacidos_por_municipio2010 <- naci_2010%>%
  group_by(municipio) %>%
  summarize(total_nacidos2010 = n())
conteo_por_municipio_final2010 <- left_join(conteo_por_municipio2010sgss2, total_nacidos_por_municipio2010, by = "municipio")
conteo_por_municipio_final2010 <- conteo_por_municipio_final2010 %>%
  mutate(porcentaje_no_asegurados2010 = round(SEG_SOCIAL / total_nacidos2010 * 100,2))
print(conteo_por_municipio_final2010)
```


```{r}
datos_2020sgss2<- left_join(datos_2020,conteo_por_municipio_final2020, by="municipio")
datos_2016sgss2<- left_join(datos_2016,conteo_por_municipio_final2016, by="municipio")
datos_2010sgss2<- left_join(datos_2010,conteo_por_municipio_final2010, by="municipio")
```

```{r}
print(datos_2020sgss2)
sum(is.na(datos_2020sgss2$SEG_SOCIAL))
```
```{r}
print(datos_2016sgss2)
sum(is.na(datos_2016sgss2$SEG_SOCIAL))
```

```{r}
print(datos_2010sgss2)
sum(is.na(datos_2010sgss2$SEG_SOCIAL))
```
#####################################################################################################

datos_2010sgss2$SEG_SOCIAL[is.na(datos_2010sgss2$SEG_SOCIAL)] <- 0
moran.test(datos_2010sgss2$SEG_SOCIAL, listw=W_vot_mat2010, zero.policy=T)

```{r}
datos_2010sgss2$porcentaje_no_asegurados2010[is.na(datos_2010sgss2$porcentaje_no_asegurados2010)] <- 0
moran.test(datos_2010sgss2$porcentaje_no_asegurados2010, listw=W_vot_mat2010, zero.policy=T)
```

datos_2016sgss2$SEG_SOCIAL[is.na(datos_2016sgss2$SEG_SOCIAL)] <- 0
moran.test(datos_2016sgss2$SEG_SOCIAL, listw=W_vot_mat2016, zero.policy=T)

```{r}
datos_2016sgss2$porcentaje_no_asegurados2016[is.na(datos_2016sgss2$porcentaje_no_asegurados2016)] <- 0
moran.test(datos_2016sgss2$porcentaje_no_asegurados2016, listw=W_vot_mat2016, zero.policy=T)
```

datos_2020sgss2$SEG_SOCIAL[is.na(datos_2020sgss2$SEG_SOCIAL)] <- 0
moran.test(datos_2020sgss2$SEG_SOCIAL, listw=W_vot_mat2020, zero.policy=T)

```{r}
datos_2020sgss2$porcentaje_no_asegurados[is.na(datos_2020sgss2$porcentaje_no_asegurados)] <- 0
moran.test(datos_2020sgss2$porcentaje_no_asegurados, listw=W_vot_mat2020, zero.policy=T)
```
assgsssprueba2<- datos_2020sgss2$porcentaje_no_asegurados/100
assgsssprueba2[is.na(assgsssprueba2)] <- 0
moran.test(assgsssprueba2, listw=W_vot_mat2020, zero.policy=T)


#####################################################################################################
#####################################################################################################

```{r}
## SEM
mod.sem2020sgss2 <- errorsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020sgss2)
```
moran.test(mod.sem2020sgss2$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sem2020sgss2 <- errorsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020sgss2)

```{r}
library(spatialreg)
mod.sar2020sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020sgss2)
```
moran.test(mod.sar2020sgss2$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sar2020sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020sgss2)

```{r}
## SDM 
mod.sdm2020sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020sgss2)
```
moran.test(mod.sdm2020sgss2$residuals, listw=W_vot_mat2020, zero.policy=TRUE)

mod.sdm2020sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados, data = datos_2020sgss2, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020sgss2)

```{r}
## SEM
mod.sem2016sgss2 <- errorsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016sgss2)
```
moran.test(mod.sem2016sgss2$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sem2016sgss2 <- errorsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2016, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016sgss2)

```{r}
library(spatialreg)
mod.sar2016sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016sgss2)
```
moran.test(mod.sar2016sgss2$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sar2016sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2016, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016sgss2)

```{r}
## SDM 
mod.sdm2016sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016sgss2)
```
moran.test(mod.sdm2016sgss2$residuals, listw=W_vot_mat2016, zero.policy=TRUE)

mod.sdm2016sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2016, data = datos_2016sgss2, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016sgss2)

```{r}
## SEM
mod.sem2010sgss2 <- errorsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010sgss2)
```
moran.test(mod.sem2010sgss2$residuals, listw=W_vot_mat2010, zero.policy=TRUE)

mod.sem2010sgss2 <- errorsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2010, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010sgss2)

```{r}
library(spatialreg)
mod.sar2010sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010sgss2)
```
moran.test(mod.sar2010sgss2$residuals, listw=W_vot_mat2010, zero.policy=TRUE)

mod.sar2010sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2010, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010sgss2)

```{r}
## SDM 
mod.sdm2010sgss2 <- lagsarlm(TMI_TERRIDATA ~ SEG_SOCIAL, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010sgss2)
```
moran.test(mod.sdm2010sgss2$residuals, listw=W_vot_mat2010, zero.policy=TRUE)

mod.sdm2010sgss2 <- lagsarlm(TMI_TERRIDATA ~ porcentaje_no_asegurados2010, data = datos_2010sgss2, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010sgss2)

## MEJOR MODELO SEG_SOCIAL

```{r}
AIC(mod.sar2010sgss2,mod.sem2010sgss2,mod.sdm2010sgss2)
```

```{r}
AIC(mod.sar2016sgss2,mod.sem2016sgss2,mod.sdm2016sgss2)
```

```{r}
AIC(mod.sar2020sgss2,mod.sem2020sgss2,mod.sdm2020sgss2)
```
#################################### MODELOS % SGSS - AFILIADOS N ###################################

ya estan



#####################################################################################################

% EDAD DE LAS MADRES: De los nacimientos ver la edad de la madre EEVV
% de Hijo nacidos vivos (HNV) de madres en grupos de riesgo: menores de 19 años y mayores de 39

#####################################################################################################

```{r}
datos_filtrados2016_edad_madre <- X2016_naci[X2016_naci$EDAD_MADRE %in% c(1, 2, 7, 8, 9), ]
head(datos_filtrados2016_edad_madre)
```

```{r}
datos_filtrados2020_edad_madre <- naci_2020[naci_2020$EDAD_MADRE %in% c(1, 2, 7, 8, 9), ]
head(datos_filtrados2020_edad_madre)
```

```{r}
datos_filtrados2010_edad_madre <- naci_2010[naci_2010$EDAD_MADRE %in% c(1, 2, 7, 8, 9), ]
head(datos_filtrados2010_edad_madre)
```

```{r}
library(dplyr)
conteo_por_municipio2010 <- datos_filtrados2010_edad_madre %>%
  filter(EDAD_MADRE %in% c(1, 2, 7, 8, 9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2010 <- conteo_por_municipio2010 %>%
  rename(edad_madre = conteo)
```

```{r}
library(dplyr)
conteo_por_municipio2016 <- datos_filtrados2016_edad_madre %>%
  filter(EDAD_MADRE %in% c(1, 2, 7, 8, 9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2016 <- conteo_por_municipio2016 %>%
  rename(edad_madre = conteo)
```

```{r}
library(dplyr)
conteo_por_municipio2020 <- datos_filtrados2020_edad_madre %>%
  filter(EDAD_MADRE %in% c(1, 2, 7, 8, 9)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2020 <- conteo_por_municipio2020 %>%
  rename(edad_madre = conteo)
```

# UNION

```{r}
head(datos_2020)
head(conteo_por_municipio2020)
datos_2020<- left_join(datos_2020,conteo_por_municipio2020, by="municipio")
head(datos_2020)
attach(datos_2020)

datos_2016<- left_join(datos_2016,conteo_por_municipio2016, by="municipio")

datos_2010<- left_join(datos_2010,conteo_por_municipio2010, by="municipio")
```

## arreglo pa pasar a porcentaje:

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2020edad <- left_join(conteo_por_municipio2020, total_nacidos_por_municipio2020, by = "municipio")

conteo_por_municipio_final2020edad <- conteo_por_municipio_final2020edad %>%
  mutate(porcentaje_edad = round(edad_madre / total_nacidos * 100,2))
print(conteo_por_municipio_final2020edad)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2016edad <- left_join(conteo_por_municipio2016, total_nacidos_por_municipio2016, by = "municipio")

conteo_por_municipio_final2016edad <- conteo_por_municipio_final2016edad %>%
  mutate(porcentaje_edad = round(edad_madre / total_nacidos2016 * 100,2))
print(conteo_por_municipio_final2016edad)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2010edad <- left_join(conteo_por_municipio2010, total_nacidos_por_municipio2010, by = "municipio")

conteo_por_municipio_final2010edad <- conteo_por_municipio_final2010edad %>%
  mutate(porcentaje_edad = round(edad_madre / total_nacidos2010 * 100,2))
print(conteo_por_municipio_final2010edad)
```

```{r}
datos_2020edad<- left_join(datos_2020,conteo_por_municipio_final2020edad, by="municipio")
datos_2016edad<- left_join(datos_2016,conteo_por_municipio_final2016edad, by="municipio")
datos_2010edad<- left_join(datos_2010,conteo_por_municipio_final2010edad, by="municipio")
```

```{r}
print(datos_2020edad)
sum(is.na(datos_2020edad$edad_madre.y))
```


# GRAFICA

```{r}
library(gridExtra)
library(ggplot2)

# Ahora, graficar los datos con la línea de regresión ajustada
ggplot(data = datos_2020, aes(x = edad_madre, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'edadmadre', y = 'log_TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))
```

# PASAR A CERO LOS DATOS FALTANTES

```{r}
datos_2020$edad_madre[is.na(datos_2020$edad_madre)] <- 0
#datos_2020sinNA <- datos_2021[complete.cases(datos_2020$edad_madre), ]

moran.test(datos_2020$edad_madre, listw=W_vot_mat2020, zero.policy=T)
```

datos_2020edad$porcentaje_edad[is.na(datos_2020edad$porcentaje_edad)] <- 0
moran.test(datos_2020edad$porcentaje_edad, listw=W_vot_mat2020, zero.policy=T)

```{r}
library(gridExtra)
library(ggplot2)

# Ahora, graficar los datos con la línea de regresión ajustada
ggplot(data = datos_2016, aes(x =log(edad_madre), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'edadmadre', y = 'log_TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))
```

```{r}
datos_2016$edad_madre[is.na(datos_2016$edad_madre)] <- 0
moran.test(datos_2016$edad_madre, listw=W_vot_mat2016, zero.policy=T)
```
datos_2016edad$porcentaje_edad[is.na(datos_2016edad$porcentaje_edad)] <- 0
moran.test(datos_2016edad$porcentaje_edad, listw=W_vot_mat2016, zero.policy=T)

```{r}
library(gridExtra)
library(ggplot2)

# Ahora, graficar los datos con la línea de regresión ajustada
ggplot(data = datos_2010, aes(x =log(edad_madre), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'edadmadre', y = 'log_TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))
```

```{r}
datos_2010$edad_madre[is.na(datos_2010$edad_madre)] <- 0
moran.test(datos_2010$edad_madre, listw=W_vot_mat2010, zero.policy=T)
```
datos_2010edad$porcentaje_edad[is.na(datos_2010edad$porcentaje_edad)] <- 0
moran.test(datos_2010edad$porcentaje_edad, listw=W_vot_mat2010, zero.policy=T)

```{r}
## SEM
mod.sem2020edadmujer <- errorsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020edadmujer)
```
moran.test(mod.sem2020edadmujer$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sem2020edadmujer <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2020edad, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020edadmujer)

```{r}
library(spatialreg)
mod.sar2020EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020EDADMUJER)
```
moran.test(mod.sar2020EDADMUJER$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sar2020EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2020edad, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020EDADMUJER)

```{r}
## SDM 
mod.sdm2020EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020EDADMUJER)
```
moran.test(mod.sdm2020EDADMUJER$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sdm2020EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2020edad, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020EDADMUJER)

```{r}
## SEM
mod.sem2016edadmujer <- errorsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016edadmujer)
```
moran.test(mod.sem2016edadmujer$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sem2016edadmujer <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2016edad, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016edadmujer)

```{r}
library(spatialreg)
mod.sar2016EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016EDADMUJER)
```
moran.test(mod.sar2016EDADMUJER$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sar2016EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2016edad, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016EDADMUJER)

```{r}
## SDM 
mod.sdm2016EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016EDADMUJER)
```
moran.test(mod.sdm2016EDADMUJER$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sdm2016EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2016edad, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016EDADMUJER)

```{r}
## SEM
mod.sem2010edadmujer <- errorsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010edadmujer)
```
moran.test(mod.sem2010edadmujer$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sem2010edadmujer <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2010edad, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010edadmujer)

```{r}
library(spatialreg)
mod.sar2010EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010EDADMUJER)
```
moran.test(mod.sar2010EDADMUJER$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sar2010EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2010edad, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010EDADMUJER)

```{r}
## SDM 
mod.sdm2010EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ edad_madre, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010EDADMUJER)
```
moran.test(mod.sdm2010EDADMUJER$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sdm2010EDADMUJER <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edad, data = datos_2010edad, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010EDADMUJER)

### mejor modelo aic
```{r}
AIC(mod.sar2010EDADMUJER,mod.sem2010edadmujer,mod.sdm2010EDADMUJER)
```

```{r}
AIC(mod.sar2016EDADMUJER,mod.sem2016edadmujer,mod.sdm2016EDADMUJER)
```

```{r}
AIC(mod.sar2020EDADMUJER,mod.sem2020edadmujer,mod.sdm2020EDADMUJER)
```

#####################################################################################################

Atención perinatal - controles prenatales

#####################################################################################################

```{r}
datos_filtrados2021_CONTROL_PRENATAL <- naci_2020[naci_2020$NUMCONSUL %in% c(0, 1, 2, 3, 4), ]
head(datos_filtrados2021_CONTROL_PRENATAL)


library(dplyr)
conteo_por_municipio2021CONTRPRE <- datos_filtrados2021_CONTROL_PRENATAL %>%
  filter( NUMCONSUL %in% c(0, 1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2021CONTRPRE <- conteo_por_municipio2021CONTRPRE %>%
  rename(NUMCONSUL = conteo)
```

```{r}
datos_filtrados2016_CONTROL_PRENATAL <- X2016_naci[X2016_naci$NUMCONSUL %in% c(0, 1, 2, 3, 4), ]
head(datos_filtrados2016_CONTROL_PRENATAL)


library(dplyr)
conteo_por_municipio2016CONTRPRE <- datos_filtrados2016_CONTROL_PRENATAL %>%
  filter( NUMCONSUL %in% c(0, 1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2016CONTRPRE <- conteo_por_municipio2016CONTRPRE %>%
  rename(NUMCONSUL = conteo)
```

```{r}
datos_filtrados2010_CONTROL_PRENATAL <- naci_2010[naci_2010$NUMCONSUL %in% c(0, 1, 2, 3, 4), ]
head(datos_filtrados2010_CONTROL_PRENATAL)


library(dplyr)
conteo_por_municipio2010CONTRPRE <- datos_filtrados2010_CONTROL_PRENATAL %>%
  filter( NUMCONSUL %in% c(0, 1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2010CONTRPRE <- conteo_por_municipio2010CONTRPRE %>%
  rename(NUMCONSUL = conteo)
```

```{r}
datos_2020_CONT<- left_join(datos_2020,conteo_por_municipio2021CONTRPRE, by="municipio")

datos_2016_CONT<- left_join(datos_2016,conteo_por_municipio2016CONTRPRE, by="municipio")

datos_2010_CONT<- left_join(datos_2010,conteo_por_municipio2010CONTRPRE, by="municipio")
```

############################################################################################################
############################################# conversion a porcentaje ######################################

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2020cntrlpre <- left_join(conteo_por_municipio2021CONTRPRE, total_nacidos_por_municipio2020, by = "municipio")

conteo_por_municipio_final2020cntrlpre <- conteo_por_municipio_final2020cntrlpre %>%
  mutate(porcentaje_cntrpre = round(NUMCONSUL / total_nacidos * 100,2))
print(conteo_por_municipio_final2020cntrlpre)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2016cntrlpre <- left_join(conteo_por_municipio2016CONTRPRE, total_nacidos_por_municipio2016, by = "municipio")

conteo_por_municipio_final2016cntrlpre <- conteo_por_municipio_final2016cntrlpre %>%
  mutate(porcentaje_cntrpre = round(NUMCONSUL / total_nacidos2016 * 100,2))
print(conteo_por_municipio_final2016cntrlpre)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2010cntrlpre <- left_join(conteo_por_municipio2010CONTRPRE, total_nacidos_por_municipio2010, by = "municipio")

conteo_por_municipio_final2010cntrlpre <- conteo_por_municipio_final2010cntrlpre %>%
  mutate(porcentaje_cntrpre = round(NUMCONSUL / total_nacidos2010 * 100,2))
print(conteo_por_municipio_final2010cntrlpre)
```

```{r}
datos_2020prenat<- left_join(datos_2020,conteo_por_municipio_final2020cntrlpre, by="municipio")
datos_2016prenat<- left_join(datos_2016,conteo_por_municipio_final2010cntrlpre, by="municipio")
datos_2010prenat<- left_join(datos_2010,conteo_por_municipio_final2016cntrlpre, by="municipio")
```

```{r}
print(datos_2020prenat)
sum(is.na(datos_2020prenat$porcentaje_cntrpre))
```

```{r}
datos_2010_CONT$NUMCONSUL[is.na(datos_2010_CONT$NUMCONSUL)] <- 0
moran.test(datos_2010_CONT$NUMCONSUL, listw=W_vot_mat2010, zero.policy=T)
```
datos_2010prenat$porcentaje_cntrpre[is.na(datos_2010prenat$porcentaje_cntrpre)] <- 0
moran.test(datos_2010prenat$porcentaje_cntrpre, listw=W_vot_mat2010, zero.policy=T)

```{r}
datos_2016_CONT$NUMCONSUL[is.na(datos_2016_CONT$NUMCONSUL)] <- 0
moran.test(datos_2016_CONT$NUMCONSUL, listw=W_vot_mat2016, zero.policy=T)
```
datos_2016prenat$porcentaje_cntrpre[is.na(datos_2016prenat$porcentaje_cntrpre)] <- 0
moran.test(datos_2016prenat$porcentaje_cntrpre, listw=W_vot_mat2016, zero.policy=T)

```{r}
datos_2020_CONT$NUMCONSUL[is.na(datos_2020_CONT$NUMCONSUL)] <- 0
moran.test(datos_2020_CONT$NUMCONSUL, listw=W_vot_mat2020, zero.policy=T)
```
datos_2020prenat$porcentaje_cntrpre[is.na(datos_2020prenat$porcentaje_cntrpre)] <- 0
moran.test(datos_2020prenat$porcentaje_cntrpre, listw=W_vot_mat2020, zero.policy=T)

```{r}
## SEM
mod.sem2020CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2020_CONT, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020CONTRPREN)
```
moran.test(mod.sem2020CONTRPREN$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sem2020CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2020prenat, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020CONTRPREN)

```{r}
library(spatialreg)
mod.sem2016CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2016_CONT, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016CONTRPREN)
```
moran.test(mod.sem2016CONTRPREN$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sem2016CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2016prenat, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016CONTRPREN)

```{r}
## SDM 
mod.sem2010CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2010_CONT, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010CONTRPREN)
```
moran.test(mod.sem2010CONTRPREN$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sem2010CONTRPREN <- errorsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2010prenat, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010CONTRPREN)

```{r}
library(spatialreg)
mod.sar2010CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2010_CONT, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010CONTRPREN)
```
moran.test(mod.sar2010CONTRPREN$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sar2010CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2010prenat, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010CONTRPREN)

```{r}
library(spatialreg)
mod.sar2016CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2016_CONT, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016CONTRPREN)
```
moran.test(mod.sar2016CONTRPREN$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sar2016CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2016prenat, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016CONTRPREN)

```{r}
library(spatialreg)
mod.sar2020CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2020_CONT, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020CONTRPREN)
```
moran.test(mod.sar2020CONTRPREN$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sar2020CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2020prenat, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020CONTRPREN)

```{r}
## SDM 
mod.sdm2010CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2010_CONT, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010CONTRPREN)
```
moran.test(mod.sdm2010CONTRPREN$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sdm2010CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2010prenat, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010CONTRPREN)

```{r}
## SDM 
mod.sdm2016CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2016_CONT, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016CONTRPREN)
```
moran.test(mod.sdm2016CONTRPREN$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sdm2016CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2016prenat, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016CONTRPREN)

```{r}
## SDM 
mod.sdm2020CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ NUMCONSUL, data = datos_2020_CONT, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020CONTRPREN)
```
moran.test(mod.sdm2020CONTRPREN$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sdm2020CONTRPREN <- lagsarlm(TMI_TERRIDATA ~ porcentaje_cntrpre, data = datos_2020prenat, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020CONTRPREN)

### mejor modelo control normal:
```{r}
AIC(mod.sar2010CONTRPREN,mod.sem2010CONTRPREN,mod.sdm2010CONTRPREN)
```

```{r}
AIC(mod.sar2016CONTRPREN,mod.sem2016CONTRPREN,mod.sdm2016CONTRPREN)
```

```{r}
AIC(mod.sar2020CONTRPREN,mod.sem2020CONTRPREN,mod.sdm2020CONTRPREN)
```


#####################################################################################################

bajo peso al nacer: % de nacidos vivos que reportaron un peso inferior a 2500 gramos

#####################################################################################################

### peso con la base de dato de nacimiento: % de nacidos vivos que reportaron un peso inferior a 2500 gramos

```{r}
datos_filtrados2020_bajo_peso <- naci_2020[naci_2020$PESO_NAC %in% c(1, 2, 3, 4), ]
head(datos_filtrados2020_bajo_peso)

library(dplyr)
conteo_por_municipio2020bajopeso <- datos_filtrados2020_bajo_peso %>%
  filter( PESO_NAC %in% c(1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2020bajopeso <- conteo_por_municipio2020bajopeso %>%
  rename(PESO_NAC = conteo)
```

```{r}
datos_filtrados2016_bajo_peso <- X2016_naci[X2016_naci$PESO_NAC %in% c(1, 2, 3, 4), ]
head(datos_filtrados2016_bajo_peso)

library(dplyr)
conteo_por_municipio2016bajopeso <- datos_filtrados2016_bajo_peso %>%
  filter( PESO_NAC %in% c(1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2016bajopeso <- conteo_por_municipio2016bajopeso %>%
  rename(PESO_NAC = conteo)
```

```{r}
datos_filtrados2010_bajo_peso <- naci_2010[naci_2010$PESO_NAC %in% c(1, 2, 3, 4), ]
head(datos_filtrados2010_bajo_peso)

library(dplyr)
conteo_por_municipio2010bajopeso <- datos_filtrados2010_bajo_peso %>%
  filter( PESO_NAC %in% c(1, 2, 3, 4)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2010bajopeso <- conteo_por_municipio2010bajopeso %>%
  rename(PESO_NAC = conteo)
```

```{r}
datos_2020_bajopeso<- left_join(datos_2020,conteo_por_municipio2020bajopeso, by="municipio")

datos_2016_bajopeso<- left_join(datos_2016,conteo_por_municipio2016bajopeso, by="municipio")

datos_2010_bajopeso<- left_join(datos_2010,conteo_por_municipio2010bajopeso, by="municipio")
```

############################################################################################################
############################################# conversion a porcentaje ######################################

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2020bajopeso <- left_join(conteo_por_municipio2020bajopeso, total_nacidos_por_municipio2020, by = "municipio")

conteo_por_municipio_final2020bajopeso <- conteo_por_municipio_final2020bajopeso %>%
  mutate(porcentaje_BAJOPESO = round(PESO_NAC / total_nacidos * 100,2))
print(conteo_por_municipio_final2020bajopeso)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2016bajopeso <- left_join(conteo_por_municipio2016bajopeso, total_nacidos_por_municipio2016, by = "municipio")

conteo_por_municipio_final2016bajopeso <- conteo_por_municipio_final2016bajopeso %>%
  mutate(porcentaje_BAJOPESO = round(PESO_NAC / total_nacidos2016 * 100,2))
print(conteo_por_municipio_final2016bajopeso)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2010bajopeso <- left_join(conteo_por_municipio2010bajopeso, total_nacidos_por_municipio2010, by = "municipio")

conteo_por_municipio_final2010bajopeso <- conteo_por_municipio_final2010bajopeso %>%
  mutate(porcentaje_BAJOPESO = round(PESO_NAC / total_nacidos2010 * 100,2))
print(conteo_por_municipio_final2010bajopeso)
```

```{r}
datos_2020bajopesoo<- left_join(datos_2020,conteo_por_municipio_final2020bajopeso, by="municipio")
datos_2016bajopesoo<- left_join(datos_2016,conteo_por_municipio_final2010bajopeso, by="municipio")
datos_2010bajopesoo<- left_join(datos_2010,conteo_por_municipio_final2016bajopeso, by="municipio")
```

```{r}
print(datos_2020bajopesoo)
sum(is.na(datos_2020bajopesoo$porcentaje_BAJOPESO))
```

#####################################################################################################

```{r}
datos_2010_bajopeso$PESO_NAC[is.na(datos_2010_bajopeso$PESO_NAC)] <- 0
moran.test(datos_2010_bajopeso$PESO_NAC, listw=W_vot_mat2010, zero.policy=T)
```
datos_2010bajopesoo$porcentaje_BAJOPESO[is.na(datos_2010bajopesoo$porcentaje_BAJOPESO)] <- 0
moran.test(datos_2010bajopesoo$porcentaje_BAJOPESO, listw=W_vot_mat2010, zero.policy=T)

```{r}
datos_2016_bajopeso$PESO_NAC[is.na(datos_2016_bajopeso$PESO_NAC)] <- 0
moran.test(datos_2016_bajopeso$PESO_NAC, listw=W_vot_mat2016, zero.policy=T)
```
datos_2016bajopesoo$porcentaje_BAJOPESO[is.na(datos_2016bajopesoo$porcentaje_BAJOPESO)] <- 0
moran.test(datos_2016bajopesoo$porcentaje_BAJOPESO, listw=W_vot_mat2016, zero.policy=T)

```{r}
datos_2020_bajopeso$PESO_NAC[is.na(datos_2020_bajopeso$PESO_NAC)] <- 0
moran.test(datos_2020_bajopeso$PESO_NAC, listw=W_vot_mat2020, zero.policy=T)
```
datos_2020bajopesoo$porcentaje_BAJOPESO[is.na(datos_2020bajopesoo$porcentaje_BAJOPESO)] <- 0
moran.test(datos_2020bajopesoo$porcentaje_BAJOPESO, listw=W_vot_mat2020, zero.policy=T)

#####################################################################################################

```{r}
## SEM
mod.sem2020bajopeso <- errorsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2020_bajopeso, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020bajopeso)
```
moran.test(mod.sem2020bajopeso$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sem2020bajopeso <- errorsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2020bajopesoo, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020bajopeso)

```{r}
library(spatialreg)
mod.sem2016bajopeso <- errorsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2016_bajopeso, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016bajopeso)
```
moran.test(mod.sem2016bajopeso$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sem2016bajopeso <- errorsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2016bajopesoo, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016bajopeso)

```{r}
## SDM 
mod.sem2010bajopeso <- errorsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2010_bajopeso, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010bajopeso)
```
moran.test(mod.sem2010bajopeso$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sem2010bajopeso <- errorsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2010bajopesoo, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010bajopeso)

```{r}
library(spatialreg)
mod.sar2010bajopeso <- lagsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2010_bajopeso, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010bajopeso)
```
moran.test(mod.sar2010bajopeso$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sar2010bajopeso <- lagsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2010bajopesoo, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010bajopeso)

```{r}
library(spatialreg)
mod.sar2016bajopeso <- lagsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2016_bajopeso, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016bajopeso)
```
moran.test(mod.sar2016bajopeso$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sar2016bajopeso <- lagsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2016bajopesoo, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016bajopeso)

```{r}
library(spatialreg)
mod.sar2020bajopeso <- lagsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2020_bajopeso, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020bajopeso)
```
moran.test(mod.sar2020bajopeso$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sar2020bajopeso <- lagsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2020bajopesoo, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020bajopeso)

```{r}
## SDM 
mod.sdm2010bajopeso <- lagsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2010_bajopeso, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010bajopeso)
```
moran.test(mod.sdm2010bajopeso$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sdm2010bajopeso <- lagsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2010bajopesoo, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010bajopeso)

```{r}
## SDM 
mod.sdm2016bajopeso <- lagsarlm(TMI_TERRIDATA ~ PESO_NAC, data = datos_2016_bajopeso, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016bajopeso)
```
moran.test(mod.sdm2016bajopeso$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sdm2016bajopeso <- lagsarlm(TMI_TERRIDATA ~ porcentaje_BAJOPESO, data = datos_2016bajopesoo, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016bajopeso)

```{r}
## SDM 
mod.sdm2020bajopeso <- lagsarlm(log_TMI ~ PESO_NAC, data = datos_2020_bajopeso, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020bajopeso)
```
moran.test(mod.sdm2020bajopeso$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sdm2020bajopeso <- lagsarlm(log_TMI ~ porcentaje_BAJOPESO, data = datos_2020bajopesoo, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020bajopeso)

## mejores modelos: peso sin %

```{r}
AIC(mod.sar2010bajopeso,mod.sem2010bajopeso,mod.sdm2010bajopeso)
```

```{r}
AIC(mod.sar2016bajopeso,mod.sem2016bajopeso,mod.sdm2016bajopeso)
```

```{r}
AIC(mod.sar2020bajopeso,mod.sem2020bajopeso,mod.sdm2020bajopeso)
```

#####################################################################################################

% de madres que reportan tener un nivel educativo inferior a secundaria completa.NIV EDUC EEVV

#####################################################################################################

```{r}
datos_filtrados2020_edusecu <- naci_2020[naci_2020$NIV_EDUM %in% c(1, 2, 3, 4, 5), ]
head(datos_filtrados2020_edusecu)

library(dplyr)
conteo_por_municipio2020edusecu <- datos_filtrados2020_edusecu %>%
  filter( NIV_EDUM %in% c(1, 2, 3, 4, 5)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2020edusecu <- conteo_por_municipio2020edusecu %>%
  rename(NIV_EDUM = conteo)
```

```{r}
datos_filtrados2016_edusecu <- X2016_naci[X2016_naci$NIV_EDUM %in% c(1, 2, 3, 4, 5), ]
head(datos_filtrados2016_edusecu)

library(dplyr)
conteo_por_municipio2016edusecu <- datos_filtrados2016_edusecu %>%
  filter( NIV_EDUM %in% c(1, 2, 3, 4, 5)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2016edusecu <- conteo_por_municipio2016edusecu %>%
  rename(NIV_EDUM = conteo)
```

```{r}
datos_filtrados2010_edusecu <- naci_2010[naci_2010$NIV_EDUM %in% c(1, 2, 3, 4, 5), ]
head(datos_filtrados2010_edusecu)

library(dplyr)
conteo_por_municipio2010edusecu <- datos_filtrados2010_edusecu %>%
  filter( NIV_EDUM %in% c(1, 2, 3, 4, 5)) %>%
  group_by(municipio) %>%
  summarize(conteo = n())

conteo_por_municipio2010edusecu <- conteo_por_municipio2010edusecu %>%
  rename(NIV_EDUM = conteo)
```

```{r}
datos_2020_edusecu<- left_join(datos_2020,conteo_por_municipio2020edusecu, by="municipio")

datos_2016_edusecu<- left_join(datos_2016,conteo_por_municipio2016edusecu, by="municipio")

datos_2010_edusecu<- left_join(datos_2010,conteo_por_municipio2010edusecu, by="municipio")
```

############################################################################################################
############################################# conversion a porcentaje ######################################

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2020edusecu <- left_join(conteo_por_municipio2020edusecu, total_nacidos_por_municipio2020, by = "municipio")

conteo_por_municipio_final2020edusecu <- conteo_por_municipio_final2020edusecu %>%
  mutate(porcentaje_edusecu = round(NIV_EDUM / total_nacidos * 100,2))
print(conteo_por_municipio_final2020edusecu)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2016edusecu <- left_join(conteo_por_municipio2016edusecu, total_nacidos_por_municipio2016, by = "municipio")

conteo_por_municipio_final2016edusecu <- conteo_por_municipio_final2016edusecu %>%
  mutate(porcentaje_edusecu = round(NIV_EDUM / total_nacidos2016 * 100,2))
print(conteo_por_municipio_final2016edusecu)
```

```{r}
#total_nacidos_por_municipio2020 <- naci_2020 %>%
  #group_by(municipio) %>%
  #summarize(total_nacidos = n())
conteo_por_municipio_final2010edusecu <- left_join(conteo_por_municipio2010edusecu, total_nacidos_por_municipio2010, by = "municipio")

conteo_por_municipio_final2010edusecu <- conteo_por_municipio_final2010edusecu %>%
  mutate(porcentaje_edusecu = round(NIV_EDUM / total_nacidos2010 * 100,2))
print(conteo_por_municipio_final2010edusecu)
```

```{r}
datos_2020edusecuu<- left_join(datos_2020,conteo_por_municipio_final2020edusecu, by="municipio")
datos_2016edusecuu<- left_join(datos_2016,conteo_por_municipio_final2016edusecu, by="municipio")
datos_2010edusecuu<- left_join(datos_2010,conteo_por_municipio_final2010edusecu, by="municipio")
```

```{r}
print(datos_2020edusecuu)
sum(is.na(datos_2020edusecuu$porcentaje_edusecu))
```

#####################################################################################################

```{r}
datos_2010_edusecu$NIV_EDUM[is.na(datos_2010_edusecu$NIV_EDUM)] <- 0
moran.test(datos_2010_edusecu$NIV_EDUM, listw=W_vot_mat2010, zero.policy=T)
```

datos_2010edusecuu$porcentaje_edusecu[is.na(datos_2010edusecuu$porcentaje_edusecu)] <- 0
moran.test(datos_2010edusecuu$porcentaje_edusecu, listw=W_vot_mat2010, zero.policy=T)

```{r}
datos_2016_edusecu$NIV_EDUM[is.na(datos_2016_edusecu$NIV_EDUM)] <- 0
moran.test(datos_2016_edusecu$NIV_EDUM, listw=W_vot_mat2016, zero.policy=T)
```

datos_2016edusecuu$porcentaje_edusecu[is.na(datos_2016edusecuu$porcentaje_edusecu)] <- 0
moran.test(datos_2016edusecuu$porcentaje_edusecu, listw=W_vot_mat2016, zero.policy=T)

```{r}
datos_2020_edusecu$NIV_EDUM[is.na(datos_2020_edusecu$NIV_EDUM)] <- 0
moran.test(datos_2020_edusecu$NIV_EDUM, listw=W_vot_mat2020, zero.policy=T)
```

datos_2020edusecuu$porcentaje_edusecu[is.na(datos_2020edusecuu$porcentaje_edusecu)] <- 0
moran.test(datos_2020edusecuu$porcentaje_edusecu, listw=W_vot_mat2020, zero.policy=T)

#####################################################################################################

```{r}
## SEM
mod.sem2020edusecu <- errorsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2020_edusecu, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020edusecu)
```

moran.test(mod.sem2020edusecu$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sem2020edusecu <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2020edusecuu, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020edusecu)

```{r}
library(spatialreg)
mod.sem2016edusecu <- errorsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2016_edusecu, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016edusecu)
```

moran.test(mod.sem2016edusecu$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sem2016edusecu <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2016edusecuu, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016edusecu)

```{r}
## SDM 
mod.sem2010edusecu <- errorsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2010_edusecu, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010edusecu)
```

moran.test(mod.sem2010edusecu$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sem2010edusecu <- errorsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2010edusecuu, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010edusecu)

```{r}
library(spatialreg)
mod.sar2010edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2010_edusecu, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010edusecu)
```

moran.test(mod.sar2010edusecu$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sar2010edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2010edusecuu, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010edusecu)

```{r}
library(spatialreg)
mod.sar2016edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2016_edusecu, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016edusecu)
```

moran.test(mod.sar2016edusecu$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sar2016edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2016edusecuu, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016edusecu)

```{r}
library(spatialreg)
mod.sar2020edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2020_edusecu, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020edusecu)
```

moran.test(mod.sar2020edusecu$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sar2020edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2020edusecuu, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020edusecu)

```{r}
## SDM 
mod.sdm2010edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2010_edusecu, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010edusecu)
```

moran.test(mod.sdm2010edusecu$residuals, listw=W_vot_mat2010, zero.policy=T)

mod.sdm2010edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2010edusecuu, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010edusecu)

```{r}
## SDM 
mod.sdm2016edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2016_edusecu, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016edusecu)
```

moran.test(mod.sdm2016edusecu$residuals, listw=W_vot_mat2016, zero.policy=T)

mod.sdm2016edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2016edusecuu, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016edusecu)

```{r}
## SDM 
mod.sdm2020edusecu <- lagsarlm(TMI_TERRIDATA ~ NIV_EDUM, data = datos_2020_edusecu, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020edusecu)
```

moran.test(mod.sdm2020edusecu$residuals, listw=W_vot_mat2020, zero.policy=T)

mod.sdm2020edusecu <- lagsarlm(TMI_TERRIDATA ~ porcentaje_edusecu, data = datos_2020edusecuu, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020edusecu)

## MEJOR MODELO: SIN %

```{r}
AIC(mod.sar2010edusecu,mod.sem2010edusecu,mod.sdm2010edusecu)
```

```{r}
AIC(mod.sar2016edusecu,mod.sem2016edusecu,mod.sdm2016edusecu)
```

```{r}
AIC(mod.sar2020edusecu,mod.sem2020edusecu,mod.sdm2020edusecu)
```

########################################################################################################################################################################################################################

MODELO MULTIVARIANTE

```{r}
library(spatialreg)
mod.sar2020mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2020mixto)
```
```{r}
library(lmtest)
residuals2 <- residuals(mod.sar2020mixto)
lm_residuos2 <- lm(residuals2^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2020)

bp_test2 <- bptest(lm_residuos2)
print(bp_test2)
```
```{r}
moran.test(mod.sar2020mixto$residuals, listw=W_vot_mat2020, zero.policy=T)
```
############################################################################################################

```{r}
library(spatialreg)
mod.sar2016mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2016mixto)
```
```{r}
library(lmtest)
residuals <- residuals(mod.sar2016mixto)
lm_residuos <- lm(residuals^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2016)

bp_test <- bptest(lm_residuos)
print(bp_test)
```
La prueba de Breusch-Pagan que realizaste indica que no hay evidencia de heterocedasticidad en los residuos del modelo. Esto se determina por el valor de p alto (0.9293), lo que sugiere que no podemos rechazar la hipótesis nula de homocedasticidad.

En términos simples, esto significa que la varianza de los residuos parece ser constante a lo largo de las observaciones, lo cual es un supuesto deseable en muchos modelos estadísticos.

Si hubiera existido heterocedasticidad significativa, el valor de p habría sido más bajo, lo que indicaría que la varianza de los residuos no es constante y que el modelo podría ser menos confiable en ciertas áreas o subgrupos de datos.

Dado que el valor de p es alto, puedes confiar en que el supuesto de homocedasticidad se mantiene para tu modelo.

```{r}
moran.test(mod.sar2016mixto$residuals, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
library(spatialreg)
mod.sar2010mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sar2010mixto)
```
```{r}
library(lmtest)
residuals3 <- residuals(mod.sar2010mixto)
lm_residuos3 <- lm(residuals3^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2010)

bp_test <- bptest(lm_residuos3)
print(bp_test)
```
```{r}
moran.test(mod.sar2010mixto$residuals, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
## SEM
mod.sem2020mixto <- errorsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2020mixto)
```
```{r}
library(lmtest)
residuals4 <- residuals(mod.sem2020mixto)
lm_residuos4 <- lm(residuals4^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2020)

bp_test <- bptest(lm_residuos4)
print(bp_test)
```
```{r}
moran.test(mod.sem2020mixto$residuals, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
## SEM
mod.sem2016mixto <- errorsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2016mixto)
```
```{r}
library(lmtest)
residuals5 <- residuals(mod.sem2016mixto)
lm_residuos5 <- lm(residuals5^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2016)

bp_test <- bptest(lm_residuos5)
print(bp_test)
```
```{r}
moran.test(mod.sem2016mixto$residuals, listw=W_vot_mat2016, zero.policy=T)
```


```{r}
## SEM
mod.sem2010mixto <- errorsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, tol.solve=1e-15)
summary(mod.sem2010mixto)
```
```{r}
library(lmtest)
residuals6 <- residuals(mod.sem2010mixto)
lm_residuos6 <- lm(residuals6^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2010)

bp_test <- bptest(lm_residuos6)
print(bp_test)
```
```{r}
moran.test(mod.sem2010mixto$residuals, listw=W_vot_mat2010, zero.policy=T)
```

```{r}
## SDM 
mod.sdm2020mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2020, listw=W_vot_mat2020, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2020mixto)
```
```{r}
library(lmtest)
residuals7 <- residuals(mod.sdm2020mixto)
lm_residuos7 <- lm(residuals7^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2020)

bp_test <- bptest(lm_residuos7)
print(bp_test)
```
```{r}
moran.test(mod.sdm2020mixto$residuals, listw=W_vot_mat2020, zero.policy=T)
```

```{r}
## SDM 
mod.sdm2016mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2016, listw=W_vot_mat2016, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2016mixto)
```
```{r}
library(lmtest)
residuals8 <- residuals(mod.sdm2016mixto)
lm_residuos8 <- lm(residuals8^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2016)

bp_test <- bptest(lm_residuos8)
print(bp_test)
```
```{r}
moran.test(mod.sdm2016mixto$residuals, listw=W_vot_mat2016, zero.policy=T)
```

```{r}
## SDM 
mod.sdm2010mixto <- lagsarlm(TMI_TERRIDATA ~ MPM01+log(produccion_percapita)+ingreso_relativo+SAFAM_TOT, data = datos_2010, listw=W_vot_mat2010, zero.policy=T, type="mixed", tol.solve=1e-15)
summary(mod.sdm2010mixto)
```
```{r}
library(lmtest)
residuals9 <- residuals(mod.sdm2010mixto)
lm_residuos9 <- lm(residuals9^2 ~ MPM01 + log(produccion_percapita) + ingreso_relativo + SAFAM_TOT, data = datos_2010)

bp_test <- bptest(lm_residuos9)
print(bp_test)
```
El resultado de la prueba de Breusch-Pagan que realizaste para el modelo mod.sdm2010mixto indica que no hay evidencia de heterocedasticidad en los residuos del modelo. Esto se determina por el valor de p alto (0.8711), lo que sugiere que no podemos rechazar la hipótesis nula de homocedasticidad.

Dado que el valor de p es alto, podemos asumir que la varianza de los residuos es constante a lo largo de las observaciones en este modelo también.

Por lo tanto, no hay indicios de que la varianza de los errores del modelo varíe con los valores ajustados o las covariables incluidas en el modelo. Esto es un buen resultado, ya que la homocedasticidad es un supuesto importante en muchos modelos estadísticos.

```{r}
moran.test(mod.sdm2010mixto$residuals, listw=W_vot_mat2010, zero.policy=T)
```

## modelos

```{r}
AIC(mod.sar2010mixto,mod.sem2010mixto,mod.sdm2010mixto)
```

```{r}
AIC(mod.sar2016mixto,mod.sem2016mixto,mod.sdm2016mixto)
```

```{r}
AIC(mod.sar2020mixto,mod.sem2020mixto,mod.sdm2020mixto)
```

########################################################################################################################################################################################################################

                                            MAPA DE TMI ARREGLO MAPA

########################################################################################################################################################################################################################

TMISIN1000 DATOS COMPLETOS

```{r}
library(ggplot2)
library(patchwork)
library(cowplot)
attach(mapa_2234456)
grafico5 <- ggplot(data = mapa_2234456) +
  geom_sf(aes(fill = TMISIN1000)) +
  scale_fill_gradient(low = "lightblue", high = "darkblue", name = "TMISIN1000", labels = scales::comma) +
  labs(title = "Mapa de Tasa de mortalidad infantil por Municipio") +
  theme_minimal()
grafico5
```
TMI_TERRIDATA TODO LOS AÑOS 

```{r}
mapa_2234456$TMI_TERRIDATA[is.na(mapa_2234456$TMI_TERRIDATA)]<- 0
grafico8 <- ggplot(data = mapa_2234456) +
  geom_sf(aes(fill = TMI_TERRIDATA)) +
  scale_fill_gradient(low = "lightblue", high = "red", name = "TMI_TERRIDATA", labels = scales::comma) +
  labs(title = "Mapa de Tasa de mortalidad infantil por Municipio") +
  theme_minimal()
grafico8
```
#### DATOS 2020

```{r}
mapa_2234456$TMI_TERRIDATA[is.na(mapa_2234456$TMI_TERRIDATA)]<- 0
grafico10 <- ggplot(data = datos_2020) +
  geom_sf(aes(fill = MPM01)) +
  scale_fill_gradient(low = "lightblue", high = "red", name = "TMI_TERRIDATA", labels = scales::comma) +
  labs(title = "Mapa del Indice de Pobreza multidimensional por Municipio") +
  theme_minimal()
grafico10
```
## GRAFICO CON TODOS LOS MUNICIPIOS:

## MAPA CON SHAPE

library(tmap)
mapa_2234456filtradosin2021 <- subset(mapa_2234456, !grepl("2021", Año))

tm_shape(mapa_2234456filtradosin2021) +
  tm_fill(col = 'TMI_TERRIDATA', 
          legend.hist = FALSE,  
          palette = "Blues",
          #breaks = c(0, 15, 30, 45, 60, 75, 90, 100)) +  # Ajusta los valores de los intervalos 
          breaks = c(0, 15, 33, 45, 60, 75, 100)) + #Ajusta los valores de los intervalos 

  tm_legend(legend.outside = TRUE, legend.outside.position = "right") +
  tm_layout(title.size = 3)  

```{r}
library(tmap)
mapa_2234456filtradosin2021 <- subset(mapa_2234456, !grepl("2021", Año))

mapa_2234456filtradosin2021$Año <- as.Date(paste0(mapa_2234456filtradosin2021$Año, "-01-01"))

ggplot(mapa_2234456filtradosin2021, aes(x = Año, y = TMI_TERRIDATA, group = municipio, color = municipio)) +
  geom_line(color = "#4477AA") +  # Por ejemplo, azul oscuro
  geom_point(size = 2, color = "#4477AA") +  # Mismo color para los puntos
  facet_wrap(~municipio, scales = 'free_y', ncol = 10) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(size = 6, angle = 90),
    axis.title = element_text(size = 8),
    legend.title = element_text(size = 4),
    legend.text = element_text(size = 4),
    strip.text = element_text(size = 6),
    plot.title = element_text(size = 10, hjust = 0.5),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"
  ) +
  labs(title = "Tasa de Mortalidad Infantil por Municipio en Santander",
       y = "TMI") +  # Cambiar el título del eje y
  scale_y_continuous(labels = scales::comma)  # Formato de etiquetas en millones
```
```{r}
library(tmap)
#mapa_2234456filtradosin2021 <- subset(mapa_2234456, !grepl("2021", Año))

#mapa_2234456filtradosin2021$Año <- as.Date(paste0(mapa_2234456filtradosin2021$Año, "-01-01"))

ggplot(mapa_2234456, aes(x = Año, y = ingreso_relativo, group = municipio, color = municipio)) +
  geom_line(color = "#4477AA") +  # Por ejemplo, azul oscuro
  geom_point(size = 2, color = "#4477AA") +  # Mismo color para los puntos
  facet_wrap(~municipio, scales = 'free_y', ncol = 10) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(size = 6, angle = 90),
    axis.title = element_text(size = 8),
    legend.title = element_text(size = 4),
    legend.text = element_text(size = 4),
    strip.text = element_text(size = 6),
    plot.title = element_text(size = 10, hjust = 0.5),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"
  ) +
  labs(title = "Ingresos Relativo por Municipio en Santander",
       y = "Ingreso Relativo") +  # Cambiar el título del eje y
  scale_y_continuous(labels = scales::comma)  # Formato de etiquetas en millones
```

```{r}
library(tmap)
#mapa_2234456filtradosin2021 <- subset(mapa_2234456, !grepl("2021", Año))

#mapa_2234456filtradosin2021$Año <- as.Date(paste0(mapa_2234456filtradosin2021$Año, "-01-01"))

ggplot(mapa_2234456, aes(x = Año, y = produccion_percapita, group = municipio, color = municipio)) +
  geom_line(color = "#4477AA") +  # Por ejemplo, azul oscuro
  geom_point(size = 2, color = "#4477AA") +  # Mismo color para los puntos
  facet_wrap(~municipio, scales = 'free_y', ncol = 10) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(size = 6, angle = 90),
    axis.title = element_text(size = 8),
    legend.title = element_text(size = 4),
    legend.text = element_text(size = 4),
    strip.text = element_text(size = 6),
    plot.title = element_text(size = 10, hjust = 0.5),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"
  ) +
  labs(title = "Produccion per capita por Municipio en Santander",
       y = "Produccion per capita") +  # Cambiar el título del eje y
  scale_y_continuous(labels = scales::comma)  # Formato de etiquetas en millones
```

## Mapas de calor y evolucion de la TMI (2010-2021) 


años_seleccionados <- c(2010, 2013, 2016, 2019)

# Crea el gráfico principal con facetas
mapa_superpuesto <- tm_shape(mapa_2234456filtradosin2021) +
  tm_borders() +  # Agrega bordes a los polígonos
  tm_layout(legend.position = c("left", "bottom"),  # Posición de la leyenda
            main.title = "Mapas de TMI en Santander",  # Añade el título principal
            main.title.position = "center",  # Centra el título principal
            legend.width = 0.1,  # Ajusta el ancho de la leyenda
            outer.margins = c(0.1, 0.01, 0.0000000000015, 0.15)) +  
  # Conserva solo el margen inferior (abajo)
  tm_facets(by = 'Año', free.coords = FALSE)  # Agrega facetas por año
# Itera sobre los años seleccionados y agrega cada mapa al gráfico principal

for (año_actual in años_seleccionados) {
  # Filtra los datos para el año actual
  datos_año_actual <- mapa_2234456filtradosin2021 %>%
    filter(Año == año_actual)
  
  # Agrega el mapa al gráfico principal
  mapa_superpuesto <- mapa_superpuesto +
    tm_fill(col = 'TMI_TERRIDATA', 
            title = paste("Mapa para la TMI en Santander"),
            #breaks = c(0, 15, 30, 45, 60, 75, 90, 200),
            breaks = c(0, 15, 30, 45, 60, 75, 90, 100),
            legend.hist = FALSE,
            title.size = 5)  # Ajusta el tamaño del título específico para cada mapa
}

# Ajusta los márgenes internos
# Ajusta los márgenes internos
mapa_superpuesto <- tm_layout(mapa_superpuesto, inner.margins = c(0, 0.01, 0, 0))
# Ajusta los márgenes externos
mapa_superpuesto <- tm_layout(mapa_superpuesto, outer.margins = c(0.05, 0,-0.1, 0))
# Ajusta el margen derecho (derecho del mapa)

# Muestra el gráfico completo
mapa_superpuesto


## Intervalos acordes a la distribución las variable que nos facilitarán las visualizaciones,

```{r}
library(classInt)
intervalos <- classIntervals(seq(from = 0, to = 1, by = 0.001),
                             n=5, style="fisher")$brks
intervalos2 <- classIntervals(seq(from = 0, to = 100, by = 0.1),
                             n=5, style="fisher")$brks

mapa_22222 <- qtm(mapa_2234456, "MPM01", fill.breaks = intervalos,
                fill.title = "IPM") +
  tm_layout(bg.color = "lightblue", 
            frame = FALSE, 
            inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
  tm_legend(legend.position = c("left", "top"))
# Mapa 2
mapa_33333 <- qtm(mapa_2234456filtradosin2021, "TMI_TERRIDATA", fill.breaks = intervalos2,
                  fill.title = "TMI") +
  tm_layout(bg.color = "lightblue", 
            frame = FALSE, 
            inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
  tm_legend(legend.position = c("left", "top"))
# Mapa 3
mapa_44444 <- qtm(mapa_2234456, "tasa", fill.breaks = intervalos2,
                  fill.title = "TMP") +
  tm_layout(bg.color = "lightblue", 
            frame = FALSE, 
            inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
  tm_legend(legend.position = c("left", "top"))

mapainglog<-qtm(mapa_2234456, "logingrela", fill.breaks = intervalos,
     fill.title = "Ingreso") +
     tm_layout(bg.color = "lightblue", 
               frame = FALSE, 
               inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
     tm_legend(legend.position = c("left", "top"))

mapaprodlog<-qtm(mapa_2234456, "logprodperca", fill.breaks = intervalos,
     fill.title = "Produccion") +
     tm_layout(bg.color = "lightblue", 
               frame = FALSE, 
               inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
     tm_legend(legend.position = c("left", "top"))
# Organizar los mapas utilizando tmap_arrange
arranged_maps <- tmap_arrange(mapa_22222, mapa_33333, mapa_44444, mapainglog, mapaprodlog, ncol = 5)
# Mostrar el gráfico combinado
print(arranged_maps)
```

aaa<-qtm(mapa_2234456, "TMI_normalizado", fill.breaks = intervalos,
+     fill.title = "TMI") + 
+     tm_layout(bg.color = "lightblue", 
+               frame = FALSE, 
+               inner.margins = c(0.05, 0.05, 0.05, 0.05)) +
+     tm_legend(legend.position = c("left", "top"))

```{r}
library(tmap)
tm_shape(mapa_22) +
  tm_fill(col = "INGRESOS TOTALES", 
          legend.hist = FALSE,  
          palette = "OrRd", 
          breaks = c(1780045000, 5000000000, 50000000000, 500000000000, 1300000000000)) +
  tm_legend(legend.outside = TRUE, legend.outside.position = "right") +
  tm_layout(title.size = 3)
```

####################################################################################################################################################################################

```{r}
datos_2021 <- subset(mapa_2234456, Año == 2021)
```

```{r}
head(datos_2021)
str(datos_2021)
library(sf)
library(spdep)
# Extraer las coordenadas de los centroides
map_crd2021 <- st_centroid(datos_2021)
# Crear vecindad de la reina
W_vot2021 <- poly2nb(datos_2021, queen = TRUE)
# Convertir vecindad en una lista de pesos espaciales
W_vot_mat2021 <- nb2listw(W_vot2021, style = "W", zero.policy = TRUE)
# Establecer los márgenes del gráfico
par(mar = rep(0, 4))
# Extraer las coordenadas x e y de map_crd
coords <- st_coordinates(map_crd2021)
# Tramar los municipios
plot(datos_2021$geometry, border = "grey")
# Agregar los centroides
points(coords[, "X"], coords[, "Y"], pch = 19, cex = 0.1, col = "red")
# Unir los centroides de municipios vecinos
for (i in 1:length(W_vot_mat2021$neighbours)) {
  vecinos <- W_vot_mat2021$neighbours[[i]]
  for (j in vecinos) {
    lines(c(coords[i, "X"], coords[j, "X"]), c(coords[i, "Y"], coords[j, "Y"]), col = "red")
  }
}
```

I de Moran graficamente:

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2020$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")

```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2020$TMI_TERRIDATA, W_vot_mat2020)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2020$TMI_TERRIDATA, listw = W_vot_mat2020)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)


# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados tmi 2021\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada


# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, labels = texto_info, pos = 4, cex = 0.5)

```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2021$MPM01, listw=W_vot_mat2021, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2021$municipio),xlab="IPM", 
           ylab="IPM (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2021$MPM01, W_vot_mat2021)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2021$MPM01, listw = W_vot_mat2021)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados IPM\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada


# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, pos = 4, cex = 0.5)

```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2021$ingreso_relativo), listw=W_vot_mat2021, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2021$municipio),xlab="ING", 
           ylab="ING (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, log(datos_2021$ingreso_relativo), W_vot_mat2021)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2021$ingreso_relativo), listw = W_vot_mat2021)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados Ingreso 2021\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada


```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2021$produccion_percapita), listw=W_vot_mat2021, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2021$municipio),xlab="PROD", 
           ylab="PROD (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, log(datos_2021$produccion_percapita), W_vot_mat2021)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2021$produccion_percapita), listw = W_vot_mat2021)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados Produccion 2021\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada

```

##########################################################################################################################################################################################################
2010

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2010$TMI_TERRIDATA, W_vot_mat2010)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2010$TMI_TERRIDATA, listw = W_vot_mat2010)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados TMI 2010\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada



```

```{r}

par(mar=c(4,4,1.5,0.5))

moran.plot(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="IPM", 
           ylab="IPM (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2010$MPM01, W_vot_mat2010)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2010$MPM01, listw = W_vot_mat2010)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados IPM 2010\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada

# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, labels = texto_info, pos = 4, cex = 0.5)

```

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(log(datos_2010$ingreso_relativo), listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="Ingreso total", 
           ylab="Ingreso (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, log(datos_2010$ingreso_relativo), W_vot_mat2010)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2010$ingreso_relativo), listw = W_vot_mat2010)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados Ingreso 2010\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada

```

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(log(datos_2010$produccion_percapita), listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="Produccion total", 
           ylab="Prod (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones,log(datos_2010$produccion_percapita), W_vot_mat2010)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2010$produccion_percapita), listw = W_vot_mat2010)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados Produccion 2010\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada

# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, pos = 4, cex = 0.5)

```

##########################################################################################################################################################################################################
2016

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2016$TMI_TERRIDATA, W_vot_mat2016)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2016$TMI_TERRIDATA, listw = W_vot_mat2016)


# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados TMI 2016\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada

```

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="IPM", 
           ylab="IPM (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, datos_2016$MPM01, W_vot_mat2016)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(datos_2016$MPM01, listw = W_vot_mat2016)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados IPM 2016\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada

# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, labels = texto_info, pos = 4, cex = 0.5)

```

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(log(datos_2016$ingreso_relativo), listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="Ingreso total", 
           ylab="Ingreso (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, log(datos_2016$ingreso_relativo), W_vot_mat2016)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2016$ingreso_relativo), listw = W_vot_mat2016)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulados Ingreso 2016\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Calcular el percentil 95 de los estadísticos simulados
percentil_95 <- quantile(resultados_simulacion, 0.95)

# Determinar los límites del histograma
hist_lims <- par("usr")

# Asegurarse de que la línea roja sea visible dentro del histograma
moran_stat <- moran_original$statistic
if (moran_stat < hist_lims[1] | moran_stat > hist_lims[2]) {
  if (moran_stat < hist_lims[1]) {
    abline(v = hist_lims[1], col = "red", lwd = 2)
  } else {
    abline(v = hist_lims[2], col = "red", lwd = 2)
  }
} else {
  abline(v = moran_stat, col = "red", lwd = 2)
}

# Agregar línea vertical en el percentil 95 de los estadísticos simulados
abline(v = percentil_95, col = "green", lwd = 2, lty = 2)  # Linea punteada


```

```{r}
par(mar=c(4,4,1.5,0.5))

moran.plot(log(datos_2016$produccion_percapita), listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="Produccion total", 
           ylab="Prod (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
# Función para realizar la simulación de Monte Carlo
simulacion_monte_carlo <- function(iteraciones, datos, matriz_pesos) {
  estadisticos_simulados <- numeric(iteraciones)
  
  for (i in 1:iteraciones) {
    # Generar datos aleatorios permutados
    datos_permutados <- sample(datos)
    
    # Calcular el estadístico de Moran para los datos permutados
    moran_permutado <- moran.test(datos_permutados, listw = matriz_pesos)
    
    # Almacenar el estadístico de Moran permutado
    estadisticos_simulados[i] <- moran_permutado$statistic
  }
  
  return(estadisticos_simulados)
}

# Configurar el número de permutaciones
num_permutaciones <- 999

# Ejecutar la simulación de Monte Carlo
resultados_simulacion <- simulacion_monte_carlo(num_permutaciones, log(datos_2016$produccion_percapita), W_vot_mat2016)

# Calcular el estadístico de Moran para los datos originales
moran_original <- moran.test(log(datos_2016$produccion_percapita), listw = W_vot_mat2016)

# Calcular el pseudo p-value
pseudo_pvalue <- mean(abs(resultados_simulacion) >= abs(moran_original$statistic))

moran_simulado <- mean(resultados_simulacion)

# Ajustar los márgenes del gráfico
par(mar = c(5, 4, 4, 6))  # Ajustar el margen derecho para dejar espacio para el texto

# Crear el histograma de los estadísticos simulados
hist(resultados_simulacion, breaks = 20, col = "skyblue", border = "white", density = 20,
     main = "Histograma de Estadísticos Simulado Produccion 2016\n", xlab = "Valor del Estadístico",
     ylab = "Frecuencia")

# Agregar línea vertical para mostrar el estadístico observado
abline(v = moran_original$statistic, col = "red", lwd = 2)

abline(v = moran_simulado, col = "green", lwd = 2, lty = 2)  # Linea punteada

# Determinar las coordenadas para el texto
coord_x <- max(resultados_simulacion) - 0.1  # Mover hacia la izquierda
coord_y <- max(density(resultados_simulacion)$y) * 0.9  # Ajustar según sea necesario

# Redondear el Moran estimado a dos cifras decimales
moran_estimado_redondeado <- round(moran_original$estimate, digits = 2)

# Agregar texto con información al lado derecho del gráfico
texto_info <- paste("Permutaciones:", num_permutaciones,
                    "\nPseudo p-value:", round(pseudo_pvalue, 4),
                    "\nMoran estimado:", moran_estimado_redondeado,
                    "\nMoran simulado:", round(mean(resultados_simulacion), 4))

# Ajustar el tamaño de la fuente del texto solo para texto_info
text(x = coord_x, y = coord_y, labels = texto_info, pos = 4, cex = 0.5)

```




########################################################################################################################################################################################################################

```{r}
# Ahora calculemos el índice local
lm1 <- localmoran(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T)
head(lm1)
datos_2020$lm1 <- abs(lm1[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2020, aes(fill = lm1)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI Absoluto 2021") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm3 <- localmoran(datos_2021$MPM01, listw=W_vot_mat2021, zero.policy=T)
head(lm3)
datos_2021$lm3 <- abs(lm3[,4]) ## Extract z-values
```

```{r}
# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm3)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  
  labs(title = "Correlación Local MPM 2021") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm4 <- localmoran(datos_2021$ingreso_relativo, listw=W_vot_mat2021, zero.policy=T)
head(lm4)
datos_2021$lm4 <- abs(lm4[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm4)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2021 Absoluto") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
lm5 <- localmoran(datos_2021$produccion_percapita, listw=W_vot_mat2021, zero.policy=T)
head(lm5)
datos_2021$lm5 <- abs(lm5[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm5)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion absoluto 2021") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

########################################################################################################################################################################################

Ya no solamente absoluto:

```{r}
library(spdep)
lm7 <- localmoran(datos_2020$TMI_TERRIDATA, listw=W_vot_mat2020, zero.policy=T)
head(lm7)
datos_2021$lm7 <- lm7[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm7)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI 2021 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm9 <- localmoran(datos_2021$MPM01, listw=W_vot_mat2021, zero.policy=T)
head(lm9)
datos_2021$lm9 <- lm9[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm9)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local IPM with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm6 <- localmoran(datos_2021$produccion_percapita, listw=W_vot_mat2021, zero.policy=T)
head(lm6)
datos_2021$lm6 <- lm6[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm6)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion per capita 2021 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```


```{r}
library(spdep)
lm10 <- localmoran(datos_2021$ingreso_relativo, listw=W_vot_mat2021, zero.policy=T)
head(lm10)
datos_2021$lm10 <- lm10[,4] ## Extract z-values (with positive and negative values)
```

```{r}
# Paso 1: Calcular los valores que deseas visualizar (lm1 en tus datos)

# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2021, aes(fill = lm10)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2021 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

########################################################################################################################################################################################################################
                                                      2016
############################################################################################################

I de Moran graficamente:

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")

```

par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2020$TMISIN1000, listw=W_vot_mat2020, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2020$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")

###

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="IPM", 
           ylab="IPM (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2016$ingreso_relativo), listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="ING", 
           ylab="ING (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2016$produccion_percapita), listw=W_vot_mat2016, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2016$municipio),xlab="PROD", 
           ylab="PROD (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2016")
```

########################################################################################################################################################################################################################

```{r}
# Ahora calculemos el índice local
lm11 <- localmoran(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T)
head(lm11)
datos_2016$lm11 <- abs(lm11[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm11)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI Absoluto 2016") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm33 <- localmoran(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T)
head(lm33)
datos_2016$lm33 <- abs(lm33[,4]) ## Extract z-values
```

```{r}
# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm33)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  
  labs(title = "Correlación Local MPM 2016") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm44 <- localmoran(datos_2016$ingreso_relativo, listw=W_vot_mat2016, zero.policy=T)
head(lm44)
datos_2016$lm44 <- abs(lm44[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm44)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2016 Absoluto") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
lm55 <- localmoran(datos_2016$produccion_percapita, listw=W_vot_mat2016, zero.policy=T)
head(lm55)
datos_2016$lm55 <- abs(lm55[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm55)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion absoluto 2016") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

########################################################################################################################################################################################

Ya no solamente absoluto:

```{r}
library(spdep)
lm77 <- localmoran(datos_2016$TMI_TERRIDATA, listw=W_vot_mat2016, zero.policy=T)
head(lm77)
datos_2016$lm77 <- lm77[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm77)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI 2016 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm99 <- localmoran(datos_2016$MPM01, listw=W_vot_mat2016, zero.policy=T)
head(lm99)
datos_2016$lm99 <- lm99[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm99)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local IPM 2016 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm66 <- localmoran(datos_2016$produccion_percapita, listw=W_vot_mat2016, zero.policy=T)
head(lm66)
datos_2016$lm66 <- lm66[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm66)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion per capita 2016 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```


```{r}
library(spdep)
lm1010 <- localmoran(datos_2016$ingreso_relativo, listw=W_vot_mat2016, zero.policy=T)
head(lm1010)
datos_2016$lm1010 <- lm1010[,4] ## Extract z-values (with positive and negative values)
```

```{r}
# Paso 1: Calcular los valores que deseas visualizar (lm1 en tus datos)

# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2016, aes(fill = lm1010)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2016 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

########################################################################################################################################################################################################################
                                                      2010
############################################################################################################

I de Moran graficamente:

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")

```

par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2020$TMISIN1000, listw=W_vot_mat2020, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2020$municipio),xlab="TMI", 
           ylab="TMI (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2021")

###

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="IPM", 
           ylab="IPM (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2010$ingreso_relativo), listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="ING", 
           ylab="ING (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

```{r}
par(mar=c(4,4,1.5,0.5))
moran.plot(log(datos_2010$produccion_percapita), listw=W_vot_mat2010, zero.policy=T,
           pch=16, col="black",cex=.5, quiet=F, labels=as.character(datos_2010$municipio),xlab="PROD", 
           ylab="PROD (Rezago Espacial)", main="I de Morán, Gráfica de Dispersión 2010")
```

########################################################################################################################################################################################################################

```{r}
# Ahora calculemos el índice local
lm111 <- localmoran(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T)
head(lm111)
datos_2010$lm111 <- abs(lm111[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm111)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI Absoluto 2010") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm333 <- localmoran(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T)
head(lm333)
datos_2010$lm333 <- abs(lm333[,4]) ## Extract z-values
```

```{r}
# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm333)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  
  labs(title = "Correlación Local MPM 2010") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
# Ahora calculemos el índice local
lm444 <- localmoran(datos_2010$ingreso_relativo, listw=W_vot_mat2010, zero.policy=T)
head(lm444)
datos_2010$lm444 <- abs(lm444[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm444)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2010 Absoluto") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
lm555 <- localmoran(datos_2010$produccion_percapita, listw=W_vot_mat2010, zero.policy=T)
head(lm555)
datos_2010$lm555 <- abs(lm555[,4]) ## Extract z-values
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm555)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion absoluto 2010") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

########################################################################################################################################################################################

Ya no solamente absoluto:

```{r}
library(spdep)
lm777 <- localmoran(datos_2010$TMI_TERRIDATA, listw=W_vot_mat2010, zero.policy=T)
head(lm777)
datos_2010$lm777 <- lm777[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm777)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local TMI 2010 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm999 <- localmoran(datos_2010$MPM01, listw=W_vot_mat2010, zero.policy=T)
head(lm999)
datos_2010$lm999 <- lm999[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm999)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local IPM 2010 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

```{r}
library(spdep)
lm666 <- localmoran(datos_2010$produccion_percapita, listw=W_vot_mat2010, zero.policy=T)
head(lm666)
datos_2010$lm666 <- lm666[,4] ## Extract z-values (with positive and negative values)
```

```{r}
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
# Crear un gráfico de dispersión utilizando ggplot2 y geom_sf
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm666)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Produccion per capita 2010 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```


```{r}
library(spdep)
lm101010 <- localmoran(datos_2010$ingreso_relativo, listw=W_vot_mat2010, zero.policy=T)
head(lm101010)
datos_2010$lm101010 <- lm101010[,4] ## Extract z-values (with positive and negative values)
```

```{r}
# Paso 1: Calcular los valores que deseas visualizar (lm1 en tus datos)

# Paso 2: Definir la paleta de colores
lm.palette <- colorRampPalette(c("white", "orange", "red"), space = "rgb")
library(ggplot2)
ggplot() +
  geom_sf(data = datos_2010, aes(fill = lm101010)) +  # 'lm1' es la columna que quieres visualizar
  scale_fill_gradientn(colors = lm.palette(20)) +  # Asignar la paleta de colores
  labs(title = "Correlación Local Ingreso Relativo 2010 with + & -") +  # Título del gráfico
  theme(panel.background = element_rect(fill = "lightblue"))  # Color de fondo del panel
```

GGPLOT RELACIONES:

```{r}
VSBN<-ggplot(data = mapa_2234456filtradosin2021, aes(x = log(ingreso_relativo), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Íngreso Relativo', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBN2<-ggplot(data = mapa_2234456filtradosin2021, aes(x = log(produccion_percapita), y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'log(Prod per capita)', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBN3<-ggplot(data = mapa_2234456filtradosin2021, aes(x = MPM01, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'IPM', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

VSBN4<-ggplot(data = mapa_2234456filtradosin2021, aes(x = TMPSIN1000, y = TMI_TERRIDATA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'TMP', y = 'TMI') +
  theme_bw() +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))


grid.arrange(VSBN, VSBN2, VSBN3, VSBN4, ncol = 4)
```


#####################################################################################################
summary(aov(mod.lm2010))
summary(mod.lm2010$residuals)

library(sf)
library(RColorBrewer)
library(ggplot2)

# Obtener los residuos del modelo lineal
res.ml2021 <- mod.lm2021$residuals

#####################################################################################################


# Definir la paleta de colores
res.palette <- colorRampPalette(c("red", "orange", "white", "lightgreen", "green"), space = "rgb")
pal <- res.palette(5)

# Calcular los intervalos de clases de los residuos
classes_fx <- classIntervals(res.ml2021, n = 5, style = "fisher")
cols <- findColours(classes_fx, pal)

# Crear el gráfico utilizando ggplot2
ggplot() +
  geom_sf(data = datos_2021, aes(fill = res.ml2021), color = "black") +
  scale_fill_gradientn(colours = c("red", "orange", "white", "lightgreen", "green"), name = "Residuals") +
  labs(title = "Residuals from OLS Model 2021") +
  theme_minimal()


#####################################################################################################

## Residual Autocorrelation
moran.test(res.ml2021, listw=W_vot_mat2021, zero.policy=T) #2021

SAR
library(sf)
library(RColorBrewer)

# Obtener los residuos del modelo lineal
res.sar2010 <- mod.sar2010$residuals

# Definir la paleta de colores
res.palette <- colorRampPalette(c("red", "orange", "white", "lightgreen", "green"), space = "rgb")
pal <- res.palette(5)

# Calcular los intervalos de clases de los residuos
classes_fx <- classIntervals(res.ml2010, n = 5, style = "fisher")
cols <- findColours(classes_fx, pal)

# Crear el gráfico utilizando ggplot2
ggplot() +
  geom_sf(data = datos_2010, aes(fill = res.sar2010), color = "black") +
  scale_fill_gradientn(colours = c("red", "orange", "white", "lightgreen", "green"), name = "Residuals") +
  labs(title = "Residuals from SAR Model 2010") +
  theme_minimal()

#####################################################################################################

## Residual Autocorrelation
moran.test(res.sar2010, listw=W_vot_mat2010, zero.policy=T)

## Efecto Equilibrio
## Extracción de Pesos
names <- attr(W_vot2010,"region.id")

W <- matrix(0,nrow=length(names),ncol=length(names))
for(i in 1:length(names)){
W[i,as.vector(W_vot2010[[i]])] <- 1
}

I <- matrix(0,nrow=nrow(datos_2010),ncol=nrow(datos_2010))
diag(I) <- 1

#####################################################################################################

datos_2010[datos_2010$municipio == 'AGUADA' | datos_2010$municipio == 'ALBANIA',]

X0 <- cbind(datos_2010$log_TMI)
X1 <- cbind(datos_2010$log_TMI)
X1[1] <- 1.1*X1[1] 
X1[13] <- 1.1*X1[13]
Xd <- X1-X0

#####################################################################################################

## Efecto Equilibrio
## SAR
beta.sar <- mod.sar2010$coefficients
rho.sar <- mod.sar2010$rho

EE.sar <- solve(I - rho.sar*W)%*%Xd*beta.sar[2]
names(EE.sar) <- datos_2010$municipio
top.sar <- EE.sar[rev(order(EE.sar))][1:20]
as.data.frame(top.sar)  ## Top 20

#####################################################################################################

## OLS
beta.lm <- mod.lm2010$coefficients
rho.lm <- 0

EE.lm <- solve(I - rho.lm*W)%*%Xd*beta.lm[2]
names(EE.lm) <- datos_2010$municipio
EE.lm[c(1,13)]
